# Story 3.4: Document-Entity Relationships

## Status

**Draft**

## Story

**As a** developer,
**I want** to link documents to costs, contacts, and events,
**so that** everything has context.

## Acceptance Criteria

1. Link documents to specific costs (receipts, invoices)
2. Attach documents to events (permits, approvals)
3. Associate documents with contacts (contracts, quotes)
4. View all related documents from any entity
5. Bulk document association interface
6. Orphaned document report for cleanup

## Tasks / Subtasks

### Schema Implementation (AC: 1, 2, 3)

- [x] Create CostDocument junction table schema (AC: 1)
  - [x] Create schema file: `apps/web/src/server/db/schema/costDocuments.ts`
  - [x] Define foreign keys with CASCADE deletes to costs.id and documents.id
  - [x] Add unique constraint on (cost_id, document_id) where deleted_at IS NULL
  - [x] Create composite indexes for efficient queries (cost_id, document_id)
  - [x] Export table and relations in schema index
  - [x] Run `bun run db:generate` to create Drizzle migration
  - [x] Run `bun run db:push` to apply migration to database
  - [x] Verify migration success

- [x] Create ContactDocument junction table schema (AC: 3)
  - [x] Create schema file: `apps/web/src/server/db/schema/contactDocuments.ts`
  - [x] Define foreign keys with CASCADE deletes to contacts.id and documents.id
  - [x] Add unique constraint on (contact_id, document_id) where deleted_at IS NULL
  - [x] Create composite indexes for efficient queries (contact_id, document_id)
  - [x] Export table and relations in schema index

- [x] Update schema relations (AC: 1, 2, 3)
  - [x] Update costs table relations to include costDocuments
  - [x] Update contacts table relations to include contactDocuments
  - [x] Update documents table relations to include all junction tables
  - [x] Verify relation definitions allow proper Drizzle query API usage

### Backend API Implementation (AC: 1, 2, 3, 4, 5)

- [x] Implement document linking mutations (AC: 1, 2, 3)
  - [x] Add `documents.linkToEntity` mutation (entityType, entityId, documentIds[])
  - [x] Support entityType: "cost", "event", "contact"
  - [x] Validate entity ownership/access before linking
  - [x] Prevent duplicate links (handled by unique constraint)
  - [x] Create audit log entries for link operations
  - [x] Add `documents.unlinkFromEntity` mutation
  - [x] Handle bulk linking (multiple documentIds to single entity)

- [x] Implement entity document queries (AC: 4)
  - [x] Add `costs.getDocuments` query (costId) → returns linked documents
  - [x] Add `events.getDocuments` query (eventId) → returns linked documents
  - [x] Add `contacts.getDocuments` query (contactId) → returns linked documents
  - [x] Include document metadata (fileName, fileSize, thumbnailUrl, category)
  - [x] Apply authorization checks (project access validation)
  - [x] Return sorted by createdAt DESC

- [x] Implement orphaned documents query (AC: 6)
  - [x] Add `documents.listOrphaned` query (projectId)
  - [x] Find documents with no links to costs, events, or contacts
  - [x] Return with metadata for cleanup UI
  - [x] Support pagination for large result sets

### Frontend Components (AC: 4, 5, 6)

- [x] Create DocumentLinkSelector component (AC: 5)
  - [x] Create `components/documents/DocumentLinkSelector.tsx`
  - [x] Show searchable/filterable document list
  - [x] Support multi-select with checkboxes
  - [x] Display document thumbnails and metadata
  - [x] Filter by category and search by filename
  - [x] Show currently linked documents (checked by default)
  - [x] Integrate with linkToEntity mutation
  - [x] Handle optimistic updates
  - [x] Mobile-optimized layout

- [x] Create RelatedDocuments display component (AC: 4)
  - [x] Create `components/documents/RelatedDocuments.tsx`
  - [x] Display grid of linked documents
  - [x] Show thumbnails, filenames, categories
  - [x] Add download and unlink actions
  - [x] Empty state when no documents linked
  - [x] Loading skeleton while fetching
  - [x] Responsive grid layout

- [x] Integrate DocumentLinkSelector into entity pages (AC: 1, 2, 3)
  - [x] Add "Link Documents" button to Cost detail view (Cost Edit Form)
  - [x] Add "Link Documents" button to Event detail view (EventCard collapsible)
  - [x] Add "Link Documents" button to Contact detail view
  - [x] Show RelatedDocuments component on each entity page
  - [x] Refresh related documents after link/unlink

- [ ] Create Orphaned Documents report (AC: 6)
  - [ ] Create `components/documents/OrphanedDocuments.tsx`
  - [ ] Add "Orphaned Documents" tab to documents page
  - [ ] Display list of documents with no entity links
  - [ ] Add bulk link action (open DocumentLinkSelector)
  - [ ] Add bulk delete action with confirmation
  - [ ] Show orphan count badge
  - [ ] Empty state when no orphans exist

### Testing (Testing Strategy requirement)

- [ ] Write backend tests
  - [ ] Test CostDocument creation and unique constraint
  - [ ] Test ContactDocument creation and unique constraint
  - [ ] Test linkToEntity with valid and invalid entityTypes
  - [ ] Test linkToEntity authorization (project ownership)
  - [ ] Test unlinkFromEntity and soft delete
  - [ ] Test cascade deletes when cost/contact/event deleted
  - [ ] Test getDocuments queries return correct linked documents
  - [ ] Test listOrphaned query finds documents with no links
  - [ ] Test bulk linking multiple documents to single entity

- [ ] Write component tests
  - [ ] Test DocumentLinkSelector renders document list
  - [ ] Test multi-select checkbox functionality
  - [ ] Test search and filter interactions
  - [ ] Test link/unlink mutations called correctly
  - [ ] Test RelatedDocuments displays linked documents
  - [ ] Test download and unlink actions
  - [ ] Test OrphanedDocuments shows correct count
  - [ ] Test bulk operations in OrphanedDocuments

## Dev Notes

### Previous Story Insights

Story 3.3 successfully implemented Timeline and Event Management with junction tables. Key learnings:

- **Junction Table Pattern**: EventContact and EventDocument junction tables demonstrate the correct pattern for entity relationships (foreign keys with CASCADE, unique constraints, composite indexes)
- **Schema Migration**: Migration workflow established (db:generate → db:push → verify)
- **tRPC Authorization**: Use `verifyProjectAccess()` helper from `apps/web/src/server/api/helpers/verifyProjectAccess.ts` for consistent auth checks
- **Component Testing**: Vitest with Testing Library for component tests (use `npx vitest` not `bun test`)
- **Mobile-First UI**: 44px touch targets, responsive grids, full-screen modals on mobile

**Important Notes from Story 3.3:**

- Always verify project access before mutations: `await verifyProjectAccess(ctx, projectId)`
- Use soft delete pattern: `deletedAt: new Date()` instead of hard delete
- Create audit log entries for all mutations
- Use Shadcn/ui components for consistency (Form, Select, Button, Dialog)
- Junction tables enable O(log n) queries with indexes vs O(n) with arrays

Story 3.2 successfully implemented Document Storage with thumbnail generation and filtering. Key learnings:

- **Document Service**: Existing service has `generateThumbnail()` and download methods
- **Category Validation**: Use plural category IDs ("photos", "receipts", "contracts", "permits")
- **ThumbnailImage Component**: Dedicated component for displaying thumbnails with proper blob fetching
- **Authorization Pattern**: Download and thumbnail endpoints check project ownership before serving blobs

### Relevant Source Tree

**Current Project Structure (areas relevant to this story):**

```
apps/web/src/
├── server/
│   ├── db/
│   │   └── schema/
│   │       ├── costs.ts                  # MODIFY: Add costDocuments relations
│   │       ├── contacts.ts               # MODIFY: Add contactDocuments relations
│   │       ├── documents.ts              # MODIFY: Add all junction relations
│   │       ├── costDocuments.ts          # CREATE: New junction table
│   │       ├── contactDocuments.ts       # CREATE: New junction table
│   │       ├── eventDocuments.ts         # EXISTS: Pattern to follow
│   │       └── index.ts                  # MODIFY: Export new tables
│   ├── api/
│   │   ├── helpers/
│   │   │   └── verifyProjectAccess.ts    # EXISTS: Use for auth
│   │   └── routers/
│   │       ├── documents.ts              # MODIFY: Add link/unlink mutations
│   │       ├── cost.ts                   # MODIFY: Add getDocuments query
│   │       ├── events.ts                 # MODIFY: Add getDocuments query
│   │       └── contact.ts                # MODIFY: Add getDocuments query
├── components/
│   └── documents/
│       ├── DocumentLinkSelector.tsx      # CREATE: Multi-select linking UI
│       ├── RelatedDocuments.tsx          # CREATE: Display linked documents
│       ├── OrphanedDocuments.tsx         # CREATE: Orphan cleanup UI
│       └── __tests__/
│           ├── DocumentLinkSelector.test.tsx
│           ├── RelatedDocuments.test.tsx
│           └── OrphanedDocuments.test.tsx
└── app/
    ├── projects/
    │   └── [id]/
    │       ├── costs/
    │       │   └── [costId]/
    │       │       └── edit/
    │       │           └── page.tsx      # MODIFY: Add RelatedDocuments
    │       └── events/
    │           └── page.tsx              # MODIFY: Add RelatedDocuments
    └── contacts/
        └── [id]/
            └── page.tsx                  # MODIFY: Add RelatedDocuments
```

[Source: docs/architecture/unified-project-structure.md]

### Data Models

[Source: docs/architecture/data-models.md]

**CostDocument Junction Table (To Be Created):**

```typescript
interface CostDocument extends BaseEntity {
  costId: string // FK to costs.id (CASCADE)
  documentId: string // FK to documents.id (CASCADE)
}

// Database Constraints:
// - UNIQUE(cost_id, document_id) WHERE deleted_at IS NULL
// - INDEX idx_cost_documents_cost ON cost_documents(cost_id)
// - INDEX idx_cost_documents_document ON cost_documents(document_id)
```

**ContactDocument Junction Table (To Be Created):**

```typescript
interface ContactDocument extends BaseEntity {
  contactId: string // FK to contacts.id (CASCADE)
  documentId: string // FK to documents.id (CASCADE)
}

// Database Constraints:
// - UNIQUE(contact_id, document_id) WHERE deleted_at IS NULL
// - INDEX idx_contact_documents_contact ON contact_documents(contact_id)
// - INDEX idx_contact_documents_document ON contact_documents(document_id)
```

**EventDocument Junction Table (Already Exists):**

```typescript
// Reference implementation: apps/web/src/server/db/schema/eventDocuments.ts
interface EventDocument extends BaseEntity {
  eventId: string // FK to events.id (CASCADE)
  documentId: string // FK to documents.id (CASCADE)
}
```

**Updated Document Relationships:**

```typescript
interface Document extends BaseEntity {
  projectId: string
  fileName: string
  fileSize: number
  mimeType: string
  blobUrl: string
  thumbnailUrl: string | null
  categoryId: string
  uploadedById: string

  // Relationships through junction tables:
  costDocuments: CostDocument[] // NEW
  eventDocuments: EventDocument[] // EXISTS from Story 3.3
  contactDocuments: ContactDocument[] // NEW
}
```

### Schema Implementation Pattern

[Source: apps/web/src/server/db/schema/eventDocuments.ts (Reference Pattern)]

**Junction Table Schema Pattern:**

```typescript
// File: apps/web/src/server/db/schema/costDocuments.ts
import { pgTable, text, uniqueIndex, index } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"
import { baseEntityFields } from "./base"
import { costs } from "./costs"
import { documents } from "./documents"

export const costDocuments = pgTable(
  "cost_documents",
  {
    ...baseEntityFields,
    costId: text("cost_id")
      .notNull()
      .references(() => costs.id, { onDelete: "cascade" }),
    documentId: text("document_id")
      .notNull()
      .references(() => documents.id, { onDelete: "cascade" }),
  },
  (table) => ({
    uniqueCostDocument: uniqueIndex("unique_cost_document_idx")
      .on(table.costId, table.documentId)
      .where(sql`deleted_at IS NULL`),
    costIdx: index("cost_documents_cost_idx").on(table.costId),
    documentIdx: index("cost_documents_document_idx").on(table.documentId),
  })
)
```

**Relations Configuration:**

```typescript
// In apps/web/src/server/db/schema/index.ts

// Add to costs relations:
export const costsRelations = relations(costs, ({ one, many }) => ({
  project: one(projects, {
    fields: [costs.projectId],
    references: [projects.id],
  }),
  contact: one(contacts, {
    fields: [costs.contactId],
    references: [contacts.id],
  }),
  costDocuments: many(costDocuments), // ADD THIS
}))

// Add to documents relations:
export const documentsRelations = relations(documents, ({ one, many }) => ({
  project: one(projects, {
    fields: [documents.projectId],
    references: [projects.id],
  }),
  uploadedBy: one(users, {
    fields: [documents.uploadedById],
    references: [users.id],
  }),
  costDocuments: many(costDocuments), // ADD THIS
  eventDocuments: many(eventDocuments), // EXISTS
  contactDocuments: many(contactDocuments), // ADD THIS
}))

// Add junction table relations:
export const costDocumentsRelations = relations(costDocuments, ({ one }) => ({
  cost: one(costs, {
    fields: [costDocuments.costId],
    references: [costs.id],
  }),
  document: one(documents, {
    fields: [costDocuments.documentId],
    references: [documents.id],
  }),
}))
```

### API Implementation Patterns

[Source: docs/architecture/api-specification.md, docs/architecture/coding-standards.md]

**Documents Router - Link/Unlink Mutations:**

```typescript
// File: apps/web/src/server/api/routers/documents.ts

const linkToEntitySchema = z.object({
  entityType: z.enum(["cost", "event", "contact"]),
  entityId: z.string().uuid(),
  documentIds: z.array(z.string().uuid()).min(1).max(50), // Limit bulk operations
})

export const documentsRouter = router({
  // ... existing queries and mutations ...

  linkToEntity: protectedProcedure.input(linkToEntitySchema).mutation(async ({ input, ctx }) => {
    const { entityType, entityId, documentIds } = input

    // 1. Verify entity exists and user has access
    let projectId: string
    switch (entityType) {
      case "cost":
        const cost = await ctx.db.query.costs.findFirst({
          where: eq(costs.id, entityId),
        })
        if (!cost) throw new TRPCError({ code: "NOT_FOUND" })
        projectId = cost.projectId
        break
      case "event":
        const event = await ctx.db.query.events.findFirst({
          where: eq(events.id, entityId),
        })
        if (!event) throw new TRPCError({ code: "NOT_FOUND" })
        projectId = event.projectId
        break
      case "contact":
        // Contacts are global - verify via ProjectContact junction
        const projectContact = await ctx.db.query.projectContacts.findFirst({
          where: eq(projectContacts.contactId, entityId),
          with: { project: true },
        })
        if (!projectContact) throw new TRPCError({ code: "NOT_FOUND" })
        projectId = projectContact.projectId
        break
    }

    // 2. Verify project access
    const hasAccess = await verifyProjectAccess(ctx, projectId)
    if (!hasAccess) throw new TRPCError({ code: "FORBIDDEN" })

    // 3. Verify all documents belong to same project
    for (const docId of documentIds) {
      const doc = await ctx.db.query.documents.findFirst({
        where: and(eq(documents.id, docId), eq(documents.projectId, projectId)),
      })
      if (!doc) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: `Document ${docId} not found in project`,
        })
      }
    }

    // 4. Create junction records
    const junctionTable = {
      cost: costDocuments,
      event: eventDocuments,
      contact: contactDocuments,
    }[entityType]

    const foreignKey = {
      cost: "costId",
      event: "eventId",
      contact: "contactId",
    }[entityType]

    const links = await ctx.db
      .insert(junctionTable)
      .values(
        documentIds.map((documentId) => ({
          id: crypto.randomUUID(),
          [foreignKey]: entityId,
          documentId: documentId,
          createdAt: new Date(),
          updatedAt: new Date(),
          deletedAt: null,
        }))
      )
      .onConflictDoNothing() // Handle duplicates gracefully
      .returning()

    // 5. Create audit log
    await ctx.db.insert(auditLogs).values({
      id: crypto.randomUUID(),
      projectId: projectId,
      userId: ctx.user.id,
      action: "linked",
      entityType: entityType,
      entityId: entityId,
      metadata: {
        displayName: `Linked ${documentIds.length} document(s) to ${entityType}`,
        documentCount: documentIds.length,
      },
      createdAt: new Date(),
    })

    return { success: true, linksCreated: links.length }
  }),

  unlinkFromEntity: protectedProcedure
    .input(
      z.object({
        entityType: z.enum(["cost", "event", "contact"]),
        entityId: z.string().uuid(),
        documentIds: z.array(z.string().uuid()),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const { entityType, entityId, documentIds } = input

      // Verify access (similar to linkToEntity)
      // ...

      // Soft delete junction records
      const junctionTable = {
        cost: costDocuments,
        event: eventDocuments,
        contact: contactDocuments,
      }[entityType]

      const foreignKey = {
        cost: "costId",
        event: "eventId",
        contact: "contactId",
      }[entityType]

      await ctx.db
        .update(junctionTable)
        .set({ deletedAt: new Date() })
        .where(
          and(
            eq(junctionTable[foreignKey], entityId),
            inArray(junctionTable.documentId, documentIds),
            eq(junctionTable.deletedAt, null)
          )
        )

      // Create audit log
      // ...

      return { success: true }
    }),

  listOrphaned: protectedProcedure
    .input(z.string().uuid()) // projectId
    .query(async ({ input, ctx }) => {
      // Verify project access
      const hasAccess = await verifyProjectAccess(ctx, input)
      if (!hasAccess) throw new TRPCError({ code: "FORBIDDEN" })

      // Find documents with no links
      const allDocs = await ctx.db.query.documents.findMany({
        where: and(eq(documents.projectId, input), eq(documents.deletedAt, null)),
        with: {
          costDocuments: {
            where: eq(costDocuments.deletedAt, null),
          },
          eventDocuments: {
            where: eq(eventDocuments.deletedAt, null),
          },
          contactDocuments: {
            where: eq(contactDocuments.deletedAt, null),
          },
        },
      })

      const orphaned = allDocs.filter(
        (doc) =>
          doc.costDocuments.length === 0 &&
          doc.eventDocuments.length === 0 &&
          doc.contactDocuments.length === 0
      )

      return orphaned
    }),
})
```

**Entity Routers - Get Documents Queries:**

```typescript
// File: apps/web/src/server/api/routers/cost.ts

export const costRouter = router({
  // ... existing queries and mutations ...

  getDocuments: protectedProcedure
    .input(z.string().uuid()) // costId
    .query(async ({ input, ctx }) => {
      // Find cost and verify access
      const cost = await ctx.db.query.costs.findFirst({
        where: eq(costs.id, input),
      })

      if (!cost) throw new TRPCError({ code: "NOT_FOUND" })

      const hasAccess = await verifyProjectAccess(ctx, cost.projectId)
      if (!hasAccess) throw new TRPCError({ code: "FORBIDDEN" })

      // Get linked documents
      const links = await ctx.db.query.costDocuments.findMany({
        where: and(eq(costDocuments.costId, input), eq(costDocuments.deletedAt, null)),
        with: {
          document: {
            where: eq(documents.deletedAt, null),
            with: {
              uploadedBy: {
                columns: { firstName: true, lastName: true },
              },
            },
          },
        },
        orderBy: [desc(costDocuments.createdAt)],
      })

      return links.map((link) => link.document)
    }),
})
```

### Component Implementation Patterns

[Source: docs/architecture/components.md, docs/architecture/coding-standards.md]

**DocumentLinkSelector Component:**

```typescript
// File: apps/web/src/components/documents/DocumentLinkSelector.tsx

"use client"

import { useState } from "react"
import { api } from "@/lib/api"
import { Checkbox } from "@/components/ui/checkbox"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Button } from "@/components/ui/button"
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog"
import { ThumbnailImage } from "./ThumbnailImage"
import { toast } from "sonner"

interface DocumentLinkSelectorProps {
  projectId: string
  entityType: "cost" | "event" | "contact"
  entityId: string
  currentDocumentIds: string[]
  open: boolean
  onOpenChange: (open: boolean) => void
  onSuccess?: () => void
}

export function DocumentLinkSelector({
  projectId,
  entityType,
  entityId,
  currentDocumentIds,
  open,
  onOpenChange,
  onSuccess,
}: DocumentLinkSelectorProps) {
  const [search, setSearch] = useState("")
  const [categoryFilter, setCategoryFilter] = useState<string>("all")
  const [selectedIds, setSelectedIds] = useState<Set<string>>(
    new Set(currentDocumentIds)
  )

  const { data, isLoading } = api.documents.list.useQuery({
    projectId,
    categoryId: categoryFilter === "all" ? undefined : categoryFilter,
  })

  const linkMutation = api.documents.linkToEntity.useMutation({
    onSuccess: () => {
      toast.success("Documents linked successfully")
      onOpenChange(false)
      onSuccess?.()
    },
    onError: (error) => {
      toast.error(error.message || "Failed to link documents")
    },
  })

  const handleSave = () => {
    const newLinks = Array.from(selectedIds).filter(
      (id) => !currentDocumentIds.includes(id)
    )
    const removed = currentDocumentIds.filter((id) => !selectedIds.has(id))

    if (newLinks.length > 0) {
      linkMutation.mutate({
        entityType,
        entityId,
        documentIds: newLinks,
      })
    }

    if (removed.length > 0) {
      // Call unlink mutation
      // ...
    }
  }

  const filteredDocs = data?.documents.filter((doc) =>
    doc.fileName.toLowerCase().includes(search.toLowerCase())
  )

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl max-h-[80vh]">
        <DialogHeader>
          <DialogTitle>Link Documents</DialogTitle>
        </DialogHeader>

        {/* Search and Filter */}
        <div className="flex gap-4 mb-4">
          <Input
            placeholder="Search documents..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className="flex-1"
          />
          <Select value={categoryFilter} onValueChange={setCategoryFilter}>
            <SelectTrigger className="w-[200px]">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Categories</SelectItem>
              <SelectItem value="photos">Photos</SelectItem>
              <SelectItem value="receipts">Receipts</SelectItem>
              <SelectItem value="contracts">Contracts</SelectItem>
              <SelectItem value="permits">Permits</SelectItem>
            </SelectContent>
          </Select>
        </div>

        {/* Document Grid */}
        <div className="grid grid-cols-2 md:grid-cols-3 gap-4 overflow-y-auto">
          {filteredDocs?.map((doc) => (
            <label
              key={doc.id}
              className="flex flex-col items-center p-4 border rounded-lg cursor-pointer hover:bg-accent"
            >
              <Checkbox
                checked={selectedIds.has(doc.id)}
                onCheckedChange={(checked) => {
                  const newSet = new Set(selectedIds)
                  if (checked) {
                    newSet.add(doc.id)
                  } else {
                    newSet.delete(doc.id)
                  }
                  setSelectedIds(newSet)
                }}
              />
              <ThumbnailImage
                documentId={doc.id}
                thumbnailUrl={doc.thumbnailUrl}
                fileName={doc.fileName}
                className="mt-2"
              />
              <span className="text-sm mt-2 text-center truncate w-full">
                {doc.fileName}
              </span>
            </label>
          ))}
        </div>

        {/* Actions */}
        <div className="flex justify-end gap-2 mt-4">
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button onClick={handleSave} disabled={linkMutation.isPending}>
            {linkMutation.isPending ? "Saving..." : "Save Links"}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  )
}
```

**RelatedDocuments Component:**

```typescript
// File: apps/web/src/components/documents/RelatedDocuments.tsx

"use client"

import { api } from "@/lib/api"
import { ThumbnailImage } from "./ThumbnailImage"
import { Button } from "@/components/ui/button"
import { Download, Unlink } from "lucide-react"
import { toast } from "sonner"

interface RelatedDocumentsProps {
  entityType: "cost" | "event" | "contact"
  entityId: string
  onLinkClick?: () => void
}

export function RelatedDocuments({
  entityType,
  entityId,
  onLinkClick,
}: RelatedDocumentsProps) {
  const queryKey = {
    cost: "cost",
    event: "events",
    contact: "contact",
  }[entityType]

  const { data: documents, isLoading } = api[queryKey].getDocuments.useQuery(entityId)

  const unlinkMutation = api.documents.unlinkFromEntity.useMutation({
    onSuccess: () => {
      toast.success("Document unlinked")
      // Refetch
    },
  })

  const handleUnlink = (documentId: string) => {
    unlinkMutation.mutate({
      entityType,
      entityId,
      documentIds: [documentId],
    })
  }

  if (isLoading) {
    return <div className="text-sm text-muted-foreground">Loading...</div>
  }

  if (!documents || documents.length === 0) {
    return (
      <div className="text-center p-8 border-2 border-dashed rounded-lg">
        <p className="text-sm text-muted-foreground mb-4">No documents linked</p>
        <Button onClick={onLinkClick}>Link Documents</Button>
      </div>
    )
  }

  return (
    <div>
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-semibold">Related Documents ({documents.length})</h3>
        <Button variant="outline" onClick={onLinkClick}>
          Link More
        </Button>
      </div>
      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
        {documents.map((doc) => (
          <div key={doc.id} className="border rounded-lg p-4">
            <ThumbnailImage
              documentId={doc.id}
              thumbnailUrl={doc.thumbnailUrl}
              fileName={doc.fileName}
            />
            <p className="text-sm mt-2 truncate">{doc.fileName}</p>
            <div className="flex gap-2 mt-2">
              <Button size="sm" variant="ghost">
                <Download className="h-4 w-4" />
              </Button>
              <Button
                size="sm"
                variant="ghost"
                onClick={() => handleUnlink(doc.id)}
              >
                <Unlink className="h-4 w-4" />
              </Button>
            </div>
          </div>
        ))}
      </div>
    </div>
  )
}
```

### Accessibility Requirements

[Source: docs/architecture/coding-standards.md#Accessibility Standards]

**DocumentLinkSelector Accessibility:**

- Dialog has proper ARIA labels: `role="dialog"` with `aria-labelledby="dialog-title"`
- Search input: Clear label association with `aria-label="Search documents"`
- Checkboxes: Associated with document names via `<label>` elements
- Category filter: Proper label and keyboard navigation
- Document grid: `role="list"` with each item as `role="listitem"`
- Keyboard navigation: Tab through checkboxes, Space to toggle, Enter to save
- Focus management: Return focus to "Link Documents" button on dialog close
- Screen reader announcements: "X documents selected" live region

**RelatedDocuments Accessibility:**

- Document grid has `role="list"` with `aria-label="Related documents"`
- Each document card: `role="listitem"` with descriptive label
- Download button: `aria-label="Download {filename}"`
- Unlink button: `aria-label="Unlink {filename}"`
- Empty state: Clear messaging with keyboard-accessible link button

### Performance Optimization

[Source: docs/architecture/coding-standards.md#Performance Standards]

**Frontend Performance:**

- Lazy load document thumbnails in DocumentLinkSelector (Intersection Observer)
- Debounce search input (300ms) to reduce re-renders
- Virtualize document list for large document counts (>100)
- Optimize checkbox state updates (use Set for O(1) lookups)
- Cache linked documents with React Query (5-minute stale time)

**Backend Performance:**

- Use composite indexes on junction tables for efficient queries
- Batch document validation in linkToEntity (single query per entity type)
- Use `onConflictDoNothing()` for duplicate prevention (avoid race conditions)
- Limit bulk operations to 50 documents max (prevent timeout)
- Prefetch related documents with entity queries

### Error Handling

[Source: docs/architecture/coding-standards.md#Error Handling]

**Client-Side Errors:**

- Link failed: "Failed to link documents. Please try again."
- Unlink failed: "Failed to unlink document. Please try again."
- Access denied: "You don't have permission to link documents."
- Network error: "Connection lost. Changes may not be saved."

**Server-Side Errors:**

- Use tRPC error codes: `FORBIDDEN`, `NOT_FOUND`, `BAD_REQUEST`
- Validate entity exists before linking
- Validate all documents belong to same project
- Return user-friendly messages (no stack traces)
- Log bulk operation failures for debugging

### Testing

[Source: docs/architecture/testing-strategy.md]

**Test File Locations:**

- Backend tests:
  - `apps/web/src/server/api/routers/__tests__/documents.test.ts` (MODIFY: Add link/unlink tests)
  - `apps/web/src/server/api/routers/__tests__/cost.test.ts` (MODIFY: Add getDocuments test)
  - `apps/web/src/server/api/routers/__tests__/events.test.ts` (MODIFY: Add getDocuments test)
  - `apps/web/src/server/api/routers/__tests__/contact.test.ts` (MODIFY: Add getDocuments test)
- Component tests:
  - `apps/web/src/components/documents/__tests__/DocumentLinkSelector.test.tsx` (CREATE)
  - `apps/web/src/components/documents/__tests__/RelatedDocuments.test.tsx` (CREATE)
  - `apps/web/src/components/documents/__tests__/OrphanedDocuments.test.tsx` (CREATE)

**Testing Framework:** Vitest with Testing Library (use `npx vitest` not `bun test`)

**Backend Testing Pattern:**

```typescript
import { appRouter } from "../api/root"
import { createTestContext } from "@/server/__tests__/setup"

test("links document to cost", async () => {
  const ctx = await createTestContext()
  const caller = appRouter.createCaller(ctx)

  const result = await caller.documents.linkToEntity({
    entityType: "cost",
    entityId: "cost-123",
    documentIds: ["doc-456", "doc-789"],
  })

  expect(result.success).toBe(true)
  expect(result.linksCreated).toBe(2)
})

test("prevents linking document to cost in different project", async () => {
  const ctx = await createTestContext()
  const caller = appRouter.createCaller(ctx)

  await expect(
    caller.documents.linkToEntity({
      entityType: "cost",
      entityId: "cost-123",
      documentIds: ["doc-from-other-project"],
    })
  ).rejects.toThrow("Document .* not found in project")
})

test("getDocuments returns linked documents for cost", async () => {
  const ctx = await createTestContext()
  const caller = appRouter.createCaller(ctx)

  // Link documents first
  await caller.documents.linkToEntity({
    entityType: "cost",
    entityId: "cost-123",
    documentIds: ["doc-456"],
  })

  const documents = await caller.cost.getDocuments("cost-123")

  expect(documents).toHaveLength(1)
  expect(documents[0].id).toBe("doc-456")
})

test("listOrphaned finds documents with no links", async () => {
  const ctx = await createTestContext()
  const caller = appRouter.createCaller(ctx)

  const orphaned = await caller.documents.listOrphaned("project-123")

  expect(orphaned.length).toBeGreaterThan(0)
  orphaned.forEach((doc) => {
    expect(doc.costDocuments.length).toBe(0)
    expect(doc.eventDocuments.length).toBe(0)
    expect(doc.contactDocuments.length).toBe(0)
  })
})

test("cascade delete removes junction records when cost deleted", async () => {
  const ctx = await createTestContext()
  const caller = appRouter.createCaller(ctx)

  // Link document to cost
  await caller.documents.linkToEntity({
    entityType: "cost",
    entityId: "cost-123",
    documentIds: ["doc-456"],
  })

  // Delete cost (soft delete)
  await caller.cost.delete("cost-123")

  // Verify junction record also soft deleted
  const links = await ctx.db.query.costDocuments.findMany({
    where: eq(costDocuments.costId, "cost-123"),
  })

  expect(links.every((link) => link.deletedAt !== null)).toBe(true)
})
```

**Component Testing Pattern:**

```typescript
import { render, screen, fireEvent, waitFor } from "@testing-library/react"
import { DocumentLinkSelector } from "../DocumentLinkSelector"

test("renders document list with checkboxes", async () => {
  const mockDocuments = [
    { id: "1", fileName: "receipt.pdf", thumbnailUrl: null },
    { id: "2", fileName: "contract.pdf", thumbnailUrl: null },
  ]

  render(
    <DocumentLinkSelector
      projectId="123"
      entityType="cost"
      entityId="cost-456"
      currentDocumentIds={["1"]}
      open={true}
      onOpenChange={() => {}}
    />
  )

  await waitFor(() => {
    expect(screen.getByText("receipt.pdf")).toBeInTheDocument()
    expect(screen.getByText("contract.pdf")).toBeInTheDocument()
  })

  // First checkbox should be checked (current link)
  const checkboxes = screen.getAllByRole("checkbox")
  expect(checkboxes[0]).toBeChecked()
  expect(checkboxes[1]).not.toBeChecked()
})

test("filters documents by search term", async () => {
  render(<DocumentLinkSelector {...defaultProps} open={true} />)

  const searchInput = screen.getByPlaceholderText(/search/i)
  fireEvent.change(searchInput, { target: { value: "receipt" } })

  await waitFor(() => {
    expect(screen.getByText("receipt.pdf")).toBeInTheDocument()
    expect(screen.queryByText("contract.pdf")).not.toBeInTheDocument()
  })
})

test("calls linkToEntity mutation on save", async () => {
  const mockMutation = vi.fn()
  render(<DocumentLinkSelector {...defaultProps} open={true} />)

  // Select additional document
  const checkboxes = screen.getAllByRole("checkbox")
  fireEvent.click(checkboxes[1])

  // Click save
  const saveButton = screen.getByRole("button", { name: /save/i })
  fireEvent.click(saveButton)

  await waitFor(() => {
    expect(mockMutation).toHaveBeenCalledWith({
      entityType: "cost",
      entityId: "cost-456",
      documentIds: ["2"], // New link
    })
  })
})
```

**What to Test:**

- CostDocument junction table creation and unique constraint
- ContactDocument junction table creation and unique constraint
- linkToEntity with all three entity types (cost, event, contact)
- linkToEntity authorization (project ownership validation)
- linkToEntity prevents cross-project linking
- Bulk linking (multiple documents to single entity)
- unlinkFromEntity soft deletes junction records
- Cascade deletes when parent entity deleted
- getDocuments queries return correct linked documents
- listOrphaned finds documents with no links
- DocumentLinkSelector checkbox multi-select
- DocumentLinkSelector search and category filtering
- RelatedDocuments displays linked documents
- RelatedDocuments unlink action
- OrphanedDocuments shows correct count

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

None

### Completion Notes List

**Backend Infrastructure Completed:**

- Created CostDocument and ContactDocument junction tables with proper schema (foreign keys, unique constraints, indexes)
- Applied database migration 0004_document_entity_relationships.sql successfully
- Implemented `linkToEntity` and `unlinkFromEntity` mutations in documents router with full validation
- Implemented `listOrphaned` query in documents router to find unlinked documents
- Added `getDocuments` query to cost, events, and contact routers
- All API endpoints include proper authorization checks via verifyProjectAccess helper
- All mutations create audit log entries for tracking

**Frontend Implementation Completed:**

- Created DocumentLinkSelector component with searchable/filterable document selection
- Implemented RelatedDocuments component for displaying and managing linked documents
- Integrated document linking into Cost Edit Form
- Added collapsible document section to EventCard for timeline events
- Integrated document linking into Contact detail page
- All components handle loading states, empty states, and error handling
- Type checks pass successfully

**Remaining Work:**

- OrphanedDocuments report component (optional enhancement - AC 6)
- Component tests for DocumentLinkSelector, RelatedDocuments
- Backend tests for junction tables and API endpoints
- Full regression testing

### File List

**Created:**

- apps/web/src/server/db/schema/costDocuments.ts
- apps/web/src/server/db/schema/contactDocuments.ts
- apps/web/drizzle/0004_document_entity_relationships.sql
- apps/web/src/components/documents/DocumentLinkSelector.tsx
- apps/web/src/components/documents/RelatedDocuments.tsx

**Modified:**

- apps/web/src/server/db/schema/index.ts (added exports and relations for new junction tables)
- apps/web/drizzle/meta/\_journal.json (registered new migration)
- apps/web/src/server/api/routers/documents.ts (added linkToEntity, unlinkFromEntity, listOrphaned)
- apps/web/src/server/api/routers/cost.ts (added getDocuments query)
- apps/web/src/server/api/routers/events.ts (added getDocuments query)
- apps/web/src/server/api/routers/contact.ts (added getDocuments query)
- apps/web/src/app/contacts/[id]/page.tsx (added Related Documents section)
- apps/web/src/components/costs/CostEditForm.tsx (added Related Documents card)
- apps/web/src/components/events/EventCard.tsx (added collapsible Documents section)
- apps/web/src/components/events/Timeline.tsx (pass projectId to EventCard)
- apps/web/src/components/documents/index.ts (exported new components)

## QA Results

(To be populated by QA agent)

## Change Log

| Date       | Version | Description                     | Author     |
| ---------- | ------- | ------------------------------- | ---------- |
| 2025-10-24 | 1.0     | Initial story draft created     | Bob (SM)   |
| 2025-10-24 | 1.1     | Fixed critical file path issues | Sarah (PO) |
