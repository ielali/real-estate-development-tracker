# Story 7.3: CSV/Excel Export for Costs and Reports

## Status

Draft

## Story

**As a** project owner needing to share financial data with accountants or partners,
**I want** to export cost data and reports in CSV and Excel formats,
**so that** I can perform external analysis and meet reporting requirements.

## Acceptance Criteria

1. [ ] "Export Costs" button visible in cost list view
2. [ ] Export menu offers CSV and Excel formats
3. [ ] Filter dialog allows date range, category, vendor selection
4. [ ] CSV export includes all cost fields with headers
5. [ ] Excel export has three sheets (Summary, Costs, Vendors)
6. [ ] Excel summary sheet includes category totals and chart
7. [ ] Excel formatting applied (headers bold, currency format, date format, column widths, freeze panes)
8. [ ] Generated files download with descriptive filenames
9. [ ] Large exports (1000+ costs) complete successfully (<10s)
10. [ ] Export history shows last 10 exports with re-download links
11. [ ] Vendor report export includes vendor totals and project count
12. [ ] Rate limiting enforced (10 exports/hour/user)
13. [ ] Export respects RBAC (users only export data they can view)
14. [ ] Export tested with special characters and unicode
15. [ ] Exported files open correctly in Excel, Google Sheets, Numbers

## Tasks / Subtasks

- [ ] Create tRPC export endpoints with RBAC (AC: 3, 9, 12, 13)
  - [ ] Add procedures to `apps/web/src/server/api/routers/cost.ts`:
    - [ ] `exportCosts` - Fetch filtered cost data for export
      - [ ] Input: projectId, filters (dateRange, categoryIds, contactIds), format (csv|excel)
      - [ ] Verify project access (use existing `verifyProjectOwnership`)
      - [ ] Query costs with filters and joins (categories, contacts, project)
      - [ ] Include all cost fields: date, description, amount, category, vendor, notes, createdBy, createdDate
      - [ ] Optimize query for 1000+ costs (select only needed fields, use indexes)
      - [ ] Return: array of cost records with related data
    - [ ] `exportVendorReport` - Generate vendor summary data
      - [ ] Input: projectId, dateRange filter
      - [ ] Verify project access
      - [ ] Aggregate costs by vendor (contactId)
      - [ ] Calculate: total spent per vendor, cost count, last transaction date
      - [ ] Return: vendor summary array
    - [ ] `recordExport` - Log export activity for history
      - [ ] Input: projectId, exportType, format, recordCount, filters
      - [ ] Create audit log entry
      - [ ] Store export metadata in exportHistory table (optional)
      - [ ] Return: export record ID
    - [ ] `getExportHistory` - Retrieve last 10 exports
      - [ ] Input: projectId, userId
      - [ ] Query export history for current user
      - [ ] Return: last 10 exports with metadata (timestamp, type, format, record count)
  - [ ] Implement rate limiting middleware for export procedures
    - [ ] Track exports per user per hour (use in-memory cache or Redis)
    - [ ] Limit: 10 exports per hour per user
    - [ ] Throw TRPCError if limit exceeded
  - [ ] Unit tests for all export procedures

- [ ] Enhance CSV export utility for full cost data (AC: 4, 14)
  - [ ] Extend `apps/web/src/lib/utils/cost-export.ts` (new file)
  - [ ] Reuse existing CSV helper functions from `category-export.ts`:
    - [ ] `escapeCsvValue` - Formula injection prevention
    - [ ] `formatCurrency` - Cents to dollars conversion
    - [ ] `formatDate` - Date formatting
    - [ ] `downloadCsv` - Browser download trigger
  - [ ] Implement `generateCostsCsv` function:
    - [ ] CSV structure:
      - [ ] Header: Project name, date range, generated date
      - [ ] Columns: Date, Description, Amount (AUD), Category, Vendor, Notes, Created By, Created Date
      - [ ] Sort by date descending (most recent first)
    - [ ] Handle special characters and unicode properly
    - [ ] Format currency with $ symbol: `$1,500.00`
    - [ ] Format dates: `DD/MM/YYYY` (Australian format)
    - [ ] Footer: Total spent, cost count
  - [ ] Implement `generateVendorReportCsv` function:
    - [ ] Columns: Vendor Name, Company, Total Spent, Cost Count, Last Transaction
    - [ ] Sort by total spent descending
    - [ ] Footer: Grand total, vendor count
  - [ ] Unit tests for CSV generation with unicode and special chars

- [ ] Create Excel export utility with multi-sheet support (AC: 5, 6, 7, 15)
  - [ ] Create `apps/web/src/lib/utils/excel-export.ts`
  - [ ] Add SheetJS (xlsx) library dependency
    - [ ] Install: `bun add xlsx`
    - [ ] TypeScript types: `@types/xlsx` (if needed)
  - [ ] Implement `generateCostsExcel` function:
    - [ ] **Sheet 1: Summary**
      - [ ] Project metadata section (name, date range, generated date)
      - [ ] Category breakdown table with totals
      - [ ] Format: Bold headers, currency formatting, borders
      - [ ] Include chart data for category totals (note: chart creation may be limited)
    - [ ] **Sheet 2: Detailed Costs**
      - [ ] All cost records with full details
      - [ ] Columns: Date, Description, Amount, Category, Vendor, Notes, Created By, Created Date
      - [ ] Format: Bold headers, currency cells with $ format, date cells with date format
      - [ ] Freeze top row (header)
      - [ ] Auto-filter enabled
      - [ ] Column widths auto-sized
    - [ ] **Sheet 3: Vendor Summary**
      - [ ] Vendor totals and statistics
      - [ ] Columns: Vendor Name, Company, Total Spent, Cost Count, Last Transaction
      - [ ] Format: Bold headers, currency format, borders
  - [ ] Apply Excel cell formatting:
    - [ ] Headers: Bold, background color, center alignment
    - [ ] Currency cells: `$#,##0.00` number format
    - [ ] Date cells: `DD/MM/YYYY` format
    - [ ] Borders: All cells with thin borders
  - [ ] Implement `downloadExcel` function:
    - [ ] Generate workbook from sheets
    - [ ] Write to binary array buffer
    - [ ] Create Blob and trigger download
  - [ ] Test Excel files in:
    - [ ] Microsoft Excel (Windows/Mac)
    - [ ] Google Sheets (upload and open)
    - [ ] Apple Numbers (Mac)
  - [ ] Unit tests for Excel generation and formatting

- [ ] Create ExportDialog component with format selection (AC: 1, 2, 3)
  - [ ] Create `apps/web/src/components/costs/ExportDialog.tsx`
  - [ ] Add "Export Costs" button to cost list toolbar (next to "Import Costs")
  - [ ] Dialog sections:
    - [ ] **Format Selection**: Radio buttons for CSV or Excel
    - [ ] **Filters**:
      - [ ] Date range picker (From/To dates)
      - [ ] Category multi-select dropdown (checkboxes)
      - [ ] Vendor multi-select dropdown (checkboxes)
      - [ ] "Select All" / "Clear All" buttons for each filter
    - [ ] **Export Preview**: Show count of costs that will be exported
    - [ ] **Action Buttons**: "Cancel" / "Export"
  - [ ] Loading state during export generation
  - [ ] Success toast with download confirmation
  - [ ] Error handling with retry option
  - [ ] Component tests for dialog interactions

- [ ] Implement export generation workflow (AC: 8, 9)
  - [ ] Client-side export flow:
    - [ ] User clicks "Export" in dialog
    - [ ] Call `exportCosts` tRPC query with filters
    - [ ] Show loading state (spinner + "Generating export...")
    - [ ] Generate CSV or Excel file client-side
    - [ ] Trigger browser download
    - [ ] Call `recordExport` mutation to log activity
    - [ ] Show success toast
  - [ ] Filename generation:
    - [ ] CSV: `{project-name}-costs-{YYYY-MM-DD}.csv`
    - [ ] Excel: `{project-name}-costs-{YYYY-MM-DD}.xlsx`
    - [ ] Vendor Report: `{project-name}-vendors-{YYYY-MM-DD}.csv`
    - [ ] Sanitize project name (replace spaces/special chars with underscores)
  - [ ] Performance optimization for large exports:
    - [ ] Stream processing if >1000 costs
    - [ ] Show progress indicator during generation
    - [ ] Target: <10 seconds for 1000+ costs
  - [ ] Integration tests for complete export workflow

- [ ] Create ExportHistory component (AC: 10)
  - [ ] Create `apps/web/src/components/costs/ExportHistory.tsx`
  - [ ] Add "Export History" button/link in export dialog or cost list
  - [ ] Display last 10 exports in table/list:
    - [ ] Columns: Date/Time, Type, Format, Record Count, File Size (estimate)
    - [ ] "Download Again" button for recent exports (if cached)
    - [ ] "Clear History" button
  - [ ] Fetch export history via `getExportHistory` query
  - [ ] Note: Re-download feature requires regenerating export (no server-side storage)
    - [ ] "Download Again" re-executes export with same filters
    - [ ] Filters stored in export history metadata
  - [ ] Component tests for history display

- [ ] Add vendor report export option (AC: 11)
  - [ ] Add "Export Vendor Report" button to cost list or export menu
  - [ ] Implement separate dialog or add to main ExportDialog
  - [ ] Call `exportVendorReport` tRPC query
  - [ ] Generate vendor CSV with summary data
  - [ ] Include columns: Vendor Name, Company, Total Spent, Cost Count, Last Transaction Date
  - [ ] Sort by total spent (highest first)
  - [ ] Component tests for vendor export

- [ ] Implement rate limiting (AC: 12)
  - [ ] Server-side rate limiting middleware:
    - [ ] Track exports per user ID
    - [ ] Use in-memory Map with timestamp array
    - [ ] Limit: 10 exports per hour (rolling window)
    - [ ] Clear old entries periodically
  - [ ] Client-side rate limit feedback:
    - [ ] Catch RATE_LIMIT_EXCEEDED error from tRPC
    - [ ] Display user-friendly message: "Export limit reached. Please try again in X minutes."
    - [ ] Show remaining export quota in UI (optional)
  - [ ] Unit tests for rate limiting logic

- [ ] Write comprehensive tests (AC: 9, 13, 14, 15)
  - [ ] Backend tests: `apps/web/src/server/api/routers/__tests__/cost-export.test.ts`
    - [ ] Test `exportCosts` with filters (date range, categories, vendors)
    - [ ] Test `exportCosts` with 1000+ costs (performance)
    - [ ] Test `exportVendorReport` data aggregation
    - [ ] Test RBAC (user can only export accessible projects)
    - [ ] Test rate limiting enforcement
    - [ ] Test export history recording
  - [ ] Utility tests: `apps/web/src/lib/utils/__tests__/cost-export.test.ts`
    - [ ] Test CSV generation with special characters
    - [ ] Test CSV generation with unicode (Chinese, Arabic, emojis)
    - [ ] Test currency formatting edge cases
    - [ ] Test CSV formula injection prevention
  - [ ] Utility tests: `apps/web/src/lib/utils/__tests__/excel-export.test.ts`
    - [ ] Test Excel workbook creation
    - [ ] Test multi-sheet generation
    - [ ] Test cell formatting (currency, dates, bold headers)
    - [ ] Test Excel file binary generation
  - [ ] Component tests for ExportDialog, ExportHistory
  - [ ] Integration tests for complete export workflow
  - [ ] Manual testing: Open generated files in Excel, Google Sheets, Numbers

## Dev Notes

### Previous Story Insights

**From Story 7.1 (Global Search):**

- PostgreSQL queries optimized with GIN indexes
- tRPC procedures use `verifyProjectOwnership` for RBAC consistency
- React Query for client-side caching and mutations

**From Story 7.2 (CSV Import):**

- CSV parsing patterns established (delimiters, quoting, encoding)
- Zod validation for data integrity
- Transaction patterns for bulk operations
- Client-side file processing (no server storage)

**Existing Export Implementation:**

- CategoryExportButton component already exists
- CSV export utility in `category-export.ts` with:
  - Formula injection prevention (`escapeCsvValue`)
  - Currency formatting (`formatCurrency`)
  - Client-side download (`downloadCsv`)
- Pattern: Fetch data via tRPC → Generate file client-side → Trigger download

### Tech Stack

[Source: [docs/architecture/tech-stack.md](docs/architecture/tech-stack.md)]

**Core Technologies:**

- Frontend: Next.js ^14.2.0, TypeScript ^5.3.0, React Query ^5.0.0
- UI: Shadcn/ui ^0.8.0, Tailwind CSS ^3.4.0
- Backend: tRPC ^10.45.0, Drizzle ORM ^0.44.6
- Database: Neon PostgreSQL (serverless)
- Validation: Zod ^3.22.0
- Testing: Vitest ^1.6.0, Testing Library ^14.0.0

**Excel Library:**

- SheetJS (xlsx) - Industry standard Excel generation library
- Features: Multi-sheet workbooks, cell formatting, formulas, charts (limited)
- TypeScript support, works in browser (no server required)
- License: Apache 2.0 (Community Edition)

### Data Models

[Source: [docs/architecture/data-models.md](docs/architecture/data-models.md)]

**Cost Entity (Export Fields):**

```typescript
interface CostExportRecord {
  // From Cost table
  id: string
  date: Date
  description: string
  amount: number // cents
  notes: string | null
  createdAt: Date

  // From Category join
  categoryName: string
  categoryDisplayName: string

  // From Contact join (vendor)
  vendorName: string | null
  vendorCompany: string | null

  // From User join (creator)
  createdByName: string
  createdByEmail: string

  // From Project join
  projectName: string
  projectId: string
}
```

**Vendor Summary (For Vendor Report):**

```typescript
interface VendorSummary {
  contactId: string
  vendorName: string // firstName + lastName or company
  company: string | null
  totalSpent: number // Sum of cost amounts in cents
  costCount: number // Count of costs
  lastTransactionDate: Date
  projectId: string
}
```

**Export History Record:**

```typescript
interface ExportHistory {
  id: string
  userId: string
  projectId: string
  exportType: "costs" | "vendor-report"
  format: "csv" | "excel"
  recordCount: number
  filters: {
    dateRange?: { start: Date; end: Date }
    categoryIds?: string[]
    contactIds?: string[]
  }
  createdAt: Date
}
```

### Existing Export Patterns

[Source: [apps/web/src/lib/utils/category-export.ts](apps/web/src/lib/utils/category-export.ts)]

**CSV Helper Functions (Reuse):**

```typescript
// Formula injection prevention
function escapeCsvValue(value: string | number | null | undefined): string {
  if (value === null || value === undefined) return ""
  const str = String(value)

  // Prevent formula injection
  if (str.match(/^[=+\-@]/)) {
    return `'${str}` // Prefix with single quote
  }

  // Escape quotes and wrap if contains special chars
  if (str.includes(",") || str.includes('"') || str.includes("\n")) {
    return `"${str.replace(/"/g, '""')}"`
  }

  return str
}

// Currency formatting (cents to dollars)
function formatCurrency(cents: number): string {
  return (cents / 100).toFixed(2)
}

// Date formatting (Australian format)
function formatDate(date: Date | null | undefined): string {
  if (!date) return "N/A"
  return new Date(date).toLocaleDateString("en-AU") // DD/MM/YYYY
}

// Client-side download
function downloadCsv(csvContent: string, filename: string): void {
  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" })
  const link = document.createElement("a")
  const url = URL.createObjectURL(blob)

  link.setAttribute("href", url)
  link.setAttribute("download", filename)
  link.style.visibility = "hidden"

  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)

  URL.revokeObjectURL(url)
}
```

**Export Pattern:**

1. User clicks "Export" button
2. Fetch data via tRPC query (React Query)
3. Generate CSV/Excel file client-side (JavaScript)
4. Trigger browser download (no server storage)
5. Record export activity in audit log

### CSV Export Format

**Cost Export CSV Structure:**

```csv
Real Estate Development Tracker - Cost Export
Project: Kitchen Renovation
Date Range: 01/01/2024 to 31/03/2024
Generated: 03/11/2024

Date,Description,Amount (AUD),Category,Vendor,Notes,Created By,Created Date
15/01/2024,Building materials,$1,500.00,Materials,ABC Supplies,Delivered on time,John Smith,15/01/2024
16/01/2024,Electrical work,$750.00,Labor,John's Electrical,,Sarah Jones,16/01/2024

TOTAL:,$2,250.00
Cost Count:,2
```

**Vendor Report CSV Structure:**

```csv
Real Estate Development Tracker - Vendor Report
Project: Kitchen Renovation
Generated: 03/11/2024

Vendor Name,Company,Total Spent (AUD),Cost Count,Last Transaction
John's Electrical,John's Electrical Pty Ltd,$5,250.00,12,28/02/2024
ABC Supplies,ABC Building Supplies,$3,120.00,8,15/03/2024

TOTAL:,$8,370.00
Vendor Count:,2
```

### Excel Export Format

**Sheet Structure:**

**Sheet 1: Summary**

```
┌──────────────────────────────────────────────┐
│ Real Estate Development Tracker              │
│ Project: Kitchen Renovation                  │
│ Date Range: 01/01/2024 - 31/03/2024         │
│ Generated: 03/11/2024                        │
└──────────────────────────────────────────────┘

Category Breakdown:
┌──────────────┬────────────┬────────────┐
│ Category     │ Amount     │ Count      │ [BOLD HEADER]
├──────────────┼────────────┼────────────┤
│ Materials    │ $5,250.00  │ 15         │
│ Labor        │ $3,120.00  │ 8          │
│ Permits      │ $850.00    │ 2          │
├──────────────┼────────────┼────────────┤
│ TOTAL        │ $9,220.00  │ 25         │ [BOLD]
└──────────────┴────────────┴────────────┘
```

**Sheet 2: Detailed Costs**

```
┌──────────┬─────────────────┬───────────┬──────────┬─────────────┬────────┬────────────┬──────────────┐
│ Date     │ Description     │ Amount    │ Category │ Vendor      │ Notes  │ Created By │ Created Date │ [BOLD, FREEZE ROW]
├──────────┼─────────────────┼───────────┼──────────┼─────────────┼────────┼────────────┼──────────────┤
│ 15/01/24 │ Building mat... │ $1,500.00 │ Material │ ABC Sup...  │ ...    │ John Smith │ 15/01/2024   │
│ 16/01/24 │ Electrical...   │ $750.00   │ Labor    │ John's E... │        │ Sarah Jo.. │ 16/01/2024   │
└──────────┴─────────────────┴───────────┴──────────┴─────────────┴────────┴────────────┴──────────────┘
[Auto-filter enabled on headers]
[Currency format: $#,##0.00]
[Date format: DD/MM/YYYY]
```

**Sheet 3: Vendor Summary**

```
┌──────────────────┬───────────────────────┬──────────────┬────────────┬──────────────────┐
│ Vendor Name      │ Company               │ Total Spent  │ Cost Count │ Last Transaction │ [BOLD]
├──────────────────┼───────────────────────┼──────────────┼────────────┼──────────────────┤
│ John's Electric. │ John's Electrical Ltd │ $5,250.00    │ 12         │ 28/02/2024       │
│ ABC Supplies     │ ABC Building Supplies │ $3,120.00    │ 8          │ 15/03/2024       │
└──────────────────┴───────────────────────┴──────────────┴────────────┴──────────────────┘
```

### Excel Generation with SheetJS

**Installation:**

```bash
bun add xlsx
```

**Basic Excel Generation:**

```typescript
import * as XLSX from "xlsx"

interface CostExportData {
  costs: CostExportRecord[]
  vendors: VendorSummary[]
  categoryTotals: CategoryTotal[]
  projectName: string
  dateRange: { start: Date | null; end: Date | null }
}

function generateCostsExcel(data: CostExportData): ArrayBuffer {
  // Create workbook
  const wb = XLSX.utils.book_new()

  // Sheet 1: Summary
  const summaryData = [
    ["Real Estate Development Tracker"],
    ["Project:", data.projectName],
    ["Date Range:", `${formatDate(data.dateRange.start)} to ${formatDate(data.dateRange.end)}`],
    ["Generated:", formatDate(new Date())],
    [],
    ["Category Breakdown:"],
    ["Category", "Amount", "Count"],
    ...data.categoryTotals.map((cat) => [
      cat.categoryName,
      cat.total / 100, // Currency formatting applied via cell format
      cat.count,
    ]),
    [
      "TOTAL",
      data.categoryTotals.reduce((sum, cat) => sum + cat.total, 0) / 100,
      data.costs.length,
    ],
  ]
  const summarySheet = XLSX.utils.aoa_to_sheet(summaryData)

  // Apply formatting to summary sheet
  applySummaryFormatting(summarySheet)

  XLSX.utils.book_append_sheet(wb, summarySheet, "Summary")

  // Sheet 2: Detailed Costs
  const costsData = data.costs.map((cost) => ({
    Date: cost.date,
    Description: cost.description,
    "Amount (AUD)": cost.amount / 100,
    Category: cost.categoryDisplayName,
    Vendor: cost.vendorName || cost.vendorCompany || "",
    Notes: cost.notes || "",
    "Created By": cost.createdByName,
    "Created Date": cost.createdAt,
  }))
  const costsSheet = XLSX.utils.json_to_sheet(costsData)

  // Apply formatting
  applyCostsFormatting(costsSheet, data.costs.length)

  XLSX.utils.book_append_sheet(wb, costsSheet, "Detailed Costs")

  // Sheet 3: Vendor Summary
  const vendorsData = data.vendors.map((vendor) => ({
    "Vendor Name": vendor.vendorName,
    Company: vendor.company || "",
    "Total Spent (AUD)": vendor.totalSpent / 100,
    "Cost Count": vendor.costCount,
    "Last Transaction": vendor.lastTransactionDate,
  }))
  const vendorsSheet = XLSX.utils.json_to_sheet(vendorsData)

  // Apply formatting
  applyVendorFormatting(vendorsSheet, data.vendors.length)

  XLSX.utils.book_append_sheet(wb, vendorsSheet, "Vendor Summary")

  // Generate binary array buffer
  return XLSX.write(wb, { bookType: "xlsx", type: "array" })
}
```

**Cell Formatting:**

```typescript
function applyCostsFormatting(sheet: XLSX.WorkSheet, rowCount: number) {
  const range = XLSX.utils.decode_range(sheet["!ref"] || "A1")

  // Freeze header row
  sheet["!freeze"] = { xSplit: 0, ySplit: 1 }

  // Auto-filter on header row
  sheet["!autofilter"] = { ref: sheet["!ref"] }

  // Format header row (row 0): Bold
  for (let col = range.s.c; col <= range.e.c; col++) {
    const cellRef = XLSX.utils.encode_cell({ r: 0, c: col })
    if (!sheet[cellRef]) continue

    sheet[cellRef].s = {
      font: { bold: true },
      fill: { fgColor: { rgb: "CCCCCC" } },
      alignment: { horizontal: "center" },
    }
  }

  // Format Amount column: Currency
  const amountCol = 2 // Column C (0-indexed)
  for (let row = 1; row <= rowCount; row++) {
    const cellRef = XLSX.utils.encode_cell({ r: row, c: amountCol })
    if (!sheet[cellRef]) continue

    sheet[cellRef].z = "$#,##0.00" // Currency format
  }

  // Format Date columns: Date format
  const dateCol = 0 // Column A
  const createdDateCol = 7 // Column H
  for (let row = 1; row <= rowCount; row++) {
    const dateCellRef = XLSX.utils.encode_cell({ r: row, c: dateCol })
    const createdCellRef = XLSX.utils.encode_cell({ r: row, c: createdDateCol })

    if (sheet[dateCellRef]) {
      sheet[dateCellRef].z = "DD/MM/YYYY"
    }
    if (sheet[createdCellRef]) {
      sheet[createdCellRef].z = "DD/MM/YYYY"
    }
  }

  // Apply borders to all cells
  applyBorders(sheet, range)

  // Auto-size columns
  const colWidths = [
    { wch: 12 }, // Date
    { wch: 30 }, // Description
    { wch: 15 }, // Amount
    { wch: 15 }, // Category
    { wch: 20 }, // Vendor
    { wch: 25 }, // Notes
    { wch: 15 }, // Created By
    { wch: 12 }, // Created Date
  ]
  sheet["!cols"] = colWidths
}

function applyBorders(sheet: XLSX.WorkSheet, range: XLSX.Range) {
  const borderStyle = {
    top: { style: "thin", color: { rgb: "000000" } },
    bottom: { style: "thin", color: { rgb: "000000" } },
    left: { style: "thin", color: { rgb: "000000" } },
    right: { style: "thin", color: { rgb: "000000" } },
  }

  for (let row = range.s.r; row <= range.e.r; row++) {
    for (let col = range.s.c; col <= range.e.c; col++) {
      const cellRef = XLSX.utils.encode_cell({ r: row, c: col })
      if (!sheet[cellRef]) continue

      if (!sheet[cellRef].s) sheet[cellRef].s = {}
      sheet[cellRef].s.border = borderStyle
    }
  }
}
```

**Download Excel File:**

```typescript
function downloadExcel(buffer: ArrayBuffer, filename: string): void {
  const blob = new Blob([buffer], {
    type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  })

  const link = document.createElement("a")
  const url = URL.createObjectURL(blob)

  link.setAttribute("href", url)
  link.setAttribute("download", filename)
  link.style.visibility = "hidden"

  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)

  URL.revokeObjectURL(url)
}
```

### Rate Limiting Implementation

**Server-Side Rate Limiter:**

```typescript
// In-memory rate limiter (use Redis for production multi-instance deployments)
const exportCounts = new Map<string, number[]>() // userId -> array of timestamps

function checkRateLimit(userId: string): void {
  const now = Date.now()
  const oneHourAgo = now - 60 * 60 * 1000

  // Get user's export timestamps
  const userExports = exportCounts.get(userId) || []

  // Filter to last hour
  const recentExports = userExports.filter((ts) => ts > oneHourAgo)

  // Check limit
  if (recentExports.length >= 10) {
    const oldestExport = Math.min(...recentExports)
    const minutesUntilReset = Math.ceil((oldestExport + 60 * 60 * 1000 - now) / (60 * 1000))

    throw new TRPCError({
      code: "TOO_MANY_REQUESTS",
      message: `Export limit reached. Please try again in ${minutesUntilReset} minutes.`,
    })
  }

  // Record this export
  recentExports.push(now)
  exportCounts.set(userId, recentExports)
}

// Cleanup old entries periodically
setInterval(
  () => {
    const oneHourAgo = Date.now() - 60 * 60 * 1000

    exportCounts.forEach((timestamps, userId) => {
      const recent = timestamps.filter((ts) => ts > oneHourAgo)
      if (recent.length === 0) {
        exportCounts.delete(userId)
      } else {
        exportCounts.set(userId, recent)
      }
    })
  },
  5 * 60 * 1000
) // Clean up every 5 minutes
```

**Usage in tRPC Procedures:**

```typescript
export const costRouter = router({
  exportCosts: protectedProcedure.input(exportCostsSchema).query(async ({ input, ctx }) => {
    // Check rate limit
    checkRateLimit(ctx.user.id)

    // Verify project access
    await verifyProjectOwnership(ctx.db, input.projectId, ctx.user.id)

    // Fetch and return cost data
    // ...
  }),
})
```

### Query Optimization for Large Exports

[Source: [docs/architecture/coding-standards.md](docs/architecture/coding-standards.md#performance-standards)]

**Optimized Cost Export Query:**

```typescript
async function fetchCostsForExport(
  db: Database,
  projectId: string,
  filters: ExportFilters
): Promise<CostExportRecord[]> {
  // Build query with only needed fields
  const query = db
    .select({
      // Cost fields
      id: costs.id,
      date: costs.date,
      description: costs.description,
      amount: costs.amount,
      notes: costs.notes,
      createdAt: costs.createdAt,

      // Category fields
      categoryName: categories.id,
      categoryDisplayName: categories.displayName,

      // Vendor fields
      vendorName: sql<string>`
        CASE
          WHEN ${contacts.company} IS NOT NULL THEN ${contacts.company}
          ELSE ${contacts.firstName} || ' ' || ${contacts.lastName}
        END
      `,
      vendorCompany: contacts.company,

      // Creator fields
      createdByName: sql<string>`${users.firstName} || ' ' || ${users.lastName}`,
      createdByEmail: users.email,

      // Project fields
      projectName: projects.name,
    })
    .from(costs)
    .innerJoin(categories, eq(costs.categoryId, categories.id))
    .leftJoin(contacts, eq(costs.contactId, contacts.id))
    .innerJoin(users, eq(costs.createdById, users.id))
    .innerJoin(projects, eq(costs.projectId, projects.id))
    .where(
      and(
        eq(costs.projectId, projectId),
        isNull(costs.deletedAt),
        isNull(projects.deletedAt),

        // Apply filters
        filters.dateRange?.start ? gte(costs.date, filters.dateRange.start) : undefined,
        filters.dateRange?.end ? lte(costs.date, filters.dateRange.end) : undefined,
        filters.categoryIds?.length ? inArray(costs.categoryId, filters.categoryIds) : undefined,
        filters.contactIds?.length ? inArray(costs.contactId, filters.contactIds) : undefined
      )
    )
    .orderBy(desc(costs.date)) // Most recent first

  // Execute query
  const results = await query

  return results
}
```

**Performance Targets:**

- 100 costs: <1 second
- 500 costs: <3 seconds
- 1000+ costs: <10 seconds

**Optimization Techniques:**

- Select only needed fields (avoid `SELECT *`)
- Use existing indexes on `projectId`, `categoryId`, `contactId`, `date`
- Filter in database (not in JavaScript)
- Limit joins to necessary tables
- Stream processing for very large exports (future enhancement)

### RBAC Enforcement

[Source: Existing `verifyProjectOwnership` helper in cost.ts]

**Access Control:**

- All export procedures use `verifyProjectOwnership` helper
- User must own project OR have accepted partner access
- Export data includes only costs from accessible projects
- Audit log records export activity with user ID

### Security Considerations

**Formula Injection Prevention:**

- Use `escapeCsvValue` for all CSV exports
- Prefix cells starting with `=`, `+`, `-`, `@` with single quote
- Already implemented in existing `category-export.ts`

**Input Validation:**

- Validate projectId (UUID)
- Validate date ranges (start <= end)
- Validate categoryIds and contactIds exist
- Rate limit enforcement (10 exports/hour/user)

**Error Messages:**

- Don't expose internal database errors
- Generic message: "Export failed. Please try again."
- Specific message for rate limiting: "Export limit reached. Try again in X minutes."

### UI/UX Patterns

[Source: [docs/architecture/coding-standards.md](docs/architecture/coding-standards.md#uiux-standards)]

**Responsive Design:**

- Mobile (375px+): Full-screen export dialog, stacked filters
- Tablet (768px+): Side-by-side format selection and filters
- Desktop (1024px+): Wide dialog with preview

**Loading States:**

- Filter selection: Show cost count preview
- Export generation: Spinner with "Generating export..." message
- Large exports: Show progress percentage (if possible)
- Success: Toast notification with filename

**Error Handling:**

- Rate limit exceeded: Show countdown timer until reset
- Network error: Offer retry button
- Invalid filters: Highlight problematic filter with message

**Accessibility:**

- Label all form inputs
- Keyboard navigation through dialog
- Screen reader announcements for export status
- Focus management in dialog

### Export History Implementation

**Storage Options:**

**Option 1: Audit Log Only (Recommended)**

- Store export metadata in existing `audit_logs` table
- Query recent exports by user ID and action type
- No additional table needed
- Export history is part of project audit trail

**Option 2: Dedicated Export History Table**

- Create `export_history` table with export metadata
- Link to audit log for consistency
- Allows more detailed export-specific fields

**Recommended Approach: Audit Log**

Reuse existing audit log infrastructure:

```typescript
// Record export in audit log
await ctx.db.insert(auditLogs).values({
  projectId: input.projectId,
  userId: ctx.user.id,
  action: "exported",
  entityType: "cost",
  entityId: "export", // Special marker for exports
  metadata: {
    displayName: `Exported ${recordCount} costs as ${format.toUpperCase()}`,
    exportType: input.type, // 'costs' | 'vendor-report'
    format: format, // 'csv' | 'excel'
    recordCount: recordCount,
    filters: input.filters,
  },
  createdAt: new Date(),
})

// Query export history
const exportHistory = await ctx.db.query.auditLogs.findMany({
  where: and(
    eq(auditLogs.projectId, projectId),
    eq(auditLogs.userId, userId),
    eq(auditLogs.action, "exported"),
    eq(auditLogs.entityType, "cost")
  ),
  orderBy: desc(auditLogs.createdAt),
  limit: 10,
})
```

**"Download Again" Feature:**

- Re-run export with stored filters from metadata
- No server-side file storage (regenerate on demand)
- Quick if data hasn't changed much

### Project Structure

[Source: [docs/architecture/unified-project-structure.md](docs/architecture/unified-project-structure.md)]

**File Locations:**

```
apps/web/
├── src/
│   ├── server/api/routers/
│   │   └── cost.ts                    # Add export procedures
│   ├── components/costs/
│   │   ├── ExportDialog.tsx           # Main export UI
│   │   ├── ExportHistory.tsx          # Export history display
│   │   └── CategoryExportButton.tsx   # Existing (reference)
│   ├── lib/utils/
│   │   ├── cost-export.ts             # CSV export utility (new)
│   │   ├── excel-export.ts            # Excel export utility (new)
│   │   └── category-export.ts         # Existing (reuse helpers)
│   └── __tests__/                     # Co-located tests
├── package.json                       # Add xlsx dependency
```

### Implementation Clarifications for Dev Agent

**CRITICAL - Verify Before Starting:**

These clarifications address missing requirements identified during PO validation. Review each before implementation.

#### 1. Excel Formatting Scope (SheetJS Library Limitations)

**CRITICAL ISSUE:** SheetJS Community Edition (free/Apache 2.0) has limited styling capabilities

**Library Verification:**

```bash
# Check if xlsx is already installed
grep -i "xlsx" package.json

# If not installed, add it:
bun add xlsx
```

**SheetJS Community Edition - Supported Features:**

```typescript
// ✅ SUPPORTED (Free Community Edition)
const supportedFormatting = {
  // Text formatting
  bold: sheet[cellRef].s = { font: { bold: true } },

  // Number formats
  currency: sheet[cellRef].z = '$#,##0.00',
  date: sheet[cellRef].z = 'DD/MM/YYYY',

  // Cell properties
  alignment: sheet[cellRef].s = { alignment: { horizontal: 'center' } },
  columnWidths: sheet['!cols'] = [{ wch: 15 }],
  rowHeights: sheet['!rows'] = [{ hpx: 20 }],

  // Sheet features
  freezePanes: sheet['!freeze'] = { xSplit: 0, ySplit: 1 },
  autoFilter: sheet['!autofilter'] = { ref: 'A1:H100' },
}

// ❌ NOT SUPPORTED (Requires Pro Edition - paid license)
const unsupportedFormatting = {
  borders: sheet[cellRef].s.border = { ... }, // Pro only
  backgroundColors: sheet[cellRef].s.fill = { fgColor: { rgb: 'CCCCCC' } }, // Pro only
  charts: '...', // Pro only
  conditionalFormatting: '...', // Pro only
  cellComments: '...', // Pro only
}
```

**Implementation Decision:**

**REMOVE BORDER FORMATTING** from code examples (lines 607-624 in original story). Use only free features:

```typescript
function applyCostsFormatting(sheet: XLSX.WorkSheet, rowCount: number) {
  const range = XLSX.utils.decode_range(sheet["!ref"] || "A1")

  // Freeze header row
  sheet["!freeze"] = { xSplit: 0, ySplit: 1 }

  // Auto-filter on header row
  sheet["!autofilter"] = { ref: sheet["!ref"] }

  // Format header row: Bold, centered
  for (let col = range.s.c; col <= range.e.c; col++) {
    const cellRef = XLSX.utils.encode_cell({ r: 0, c: col })
    if (!sheet[cellRef]) continue

    sheet[cellRef].s = {
      font: { bold: true },
      alignment: { horizontal: "center" },
    }
  }

  // Format Amount column: Currency
  const amountCol = 2 // Column C
  for (let row = 1; row <= rowCount; row++) {
    const cellRef = XLSX.utils.encode_cell({ r: row, c: amountCol })
    if (sheet[cellRef]) {
      sheet[cellRef].z = "$#,##0.00"
    }
  }

  // Format Date columns: Date format
  const dateCol = 0 // Column A
  const createdDateCol = 7 // Column H
  for (let row = 1; row <= rowCount; row++) {
    const dateCellRef = XLSX.utils.encode_cell({ r: row, c: dateCol })
    const createdCellRef = XLSX.utils.encode_cell({ r: row, c: createdDateCol })

    if (sheet[dateCellRef]) {
      sheet[dateCellRef].z = "DD/MM/YYYY"
    }
    if (sheet[createdCellRef]) {
      sheet[createdCellRef].z = "DD/MM/YYYY"
    }
  }

  // Auto-size columns
  sheet["!cols"] = [
    { wch: 12 }, // Date
    { wch: 30 }, // Description
    { wch: 15 }, // Amount
    { wch: 15 }, // Category
    { wch: 20 }, // Vendor
    { wch: 25 }, // Notes
    { wch: 15 }, // Created By
    { wch: 12 }, // Created Date
  ]
}

// IMPORTANT: Remove applyBorders() function entirely (not supported)
```

**AC 7 Adjustment:**

- **Current:** "Excel formatting applied (headers bold, currency format, **borders**)"
- **Revised:** "Excel formatting applied (headers bold, currency format, date format, column widths, freeze panes)"

**Document in Dev Agent Record:**

```
Excel formatting implemented with SheetJS Community Edition (free).
Borders and background colors not available in free version - excluded from implementation.
All other formatting (bold, currency, dates, column widths, freeze panes) working correctly.
Tested in Excel, Google Sheets, and Numbers - formatting preserved across platforms.
```

#### 2. Export History Storage Implementation

**Decision: Use Audit Log (No New Table)**

The story mentions two options but recommends audit log approach. This is the correct decision.

**Implementation:**

```typescript
// Record export in audit log
async function recordExport(
  db: Database,
  projectId: string,
  userId: string,
  exportData: {
    type: "costs" | "vendor-report"
    format: "csv" | "excel"
    recordCount: number
    filters: ExportFilters
  }
): Promise<void> {
  await db.insert(auditLogs).values({
    projectId,
    userId,
    action: "exported",
    entityType: "cost",
    entityId: "export", // Special marker for exports
    metadata: {
      displayName: `Exported ${exportData.recordCount} ${exportData.type === "vendor-report" ? "vendors" : "costs"} as ${exportData.format.toUpperCase()}`,
      exportType: exportData.type,
      format: exportData.format,
      recordCount: exportData.recordCount,
      filters: exportData.filters, // Store for "Download Again" feature
    },
    createdAt: new Date(),
  })
}

// Query export history
async function getExportHistory(
  db: Database,
  projectId: string,
  userId: string
): Promise<ExportHistoryRecord[]> {
  const history = await db.query.auditLogs.findMany({
    where: and(
      eq(auditLogs.projectId, projectId),
      eq(auditLogs.userId, userId),
      eq(auditLogs.action, "exported"),
      eq(auditLogs.entityType, "cost")
    ),
    orderBy: desc(auditLogs.createdAt),
    limit: 10,
  })

  return history.map((log) => ({
    id: log.id,
    timestamp: log.createdAt,
    type: log.metadata.exportType,
    format: log.metadata.format,
    recordCount: log.metadata.recordCount,
    filters: log.metadata.filters,
  }))
}
```

**"Download Again" Feature:**

- Re-executes export with stored filters from metadata
- No server-side file storage (regenerate on demand)
- Quick if data hasn't changed significantly
- Button label: "Export Again" (clearer than "Download Again")

#### 3. Filename Sanitization Rules

**Problem:** Project names may contain special characters that are invalid in filenames

**Implementation:**

```typescript
/**
 * Sanitize project name for use in export filename
 * - Convert to lowercase
 * - Replace non-alphanumeric characters with underscores
 * - Remove leading/trailing underscores
 * - Limit length to 50 characters for filesystem compatibility
 */
function sanitizeFilename(projectName: string): string {
  return (
    projectName
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "_") // Replace non-alphanumeric with underscore
      .replace(/^_+|_+$/g, "") // Remove leading/trailing underscores
      .substring(0, 50) || // Limit length
    "project"
  ) // Fallback if result is empty
}

// Generate export filename
function generateExportFilename(
  projectName: string,
  type: "costs" | "vendor-report",
  format: "csv" | "excel"
): string {
  const sanitized = sanitizeFilename(projectName)
  const timestamp = new Date().toISOString().split("T")[0] // YYYY-MM-DD
  const typeStr = type === "vendor-report" ? "vendors" : "costs"
  const extension = format === "csv" ? "csv" : "xlsx"

  return `${sanitized}_${typeStr}_${timestamp}.${extension}`
}

// Examples:
// "Kitchen Renovation" → "kitchen_renovation_costs_2024-11-03.csv"
// "Property #123 (Main St.)" → "property_123_main_st_costs_2024-11-03.xlsx"
// "Project!!!!" → "project_costs_2024-11-03.csv"
// "中文项目名称" → "project_costs_2024-11-03.csv" (fallback)
```

**Edge Cases:**

- Empty after sanitization: Use "project" as fallback
- Unicode characters: Removed by regex, fallback to "project"
- Very long names: Truncated to 50 characters
- Only special characters: Results in empty string, use fallback

#### 4. Vendor Name Aggregation Logic

**Problem:** Vendors can have company name OR firstName/lastName - need consistent display

**Implementation:**

```typescript
// In SQL query (Drizzle)
const costs = await db
  .select({
    // ... other fields
    vendorName: sql<string>`
      CASE
        WHEN ${contacts.company} IS NOT NULL AND ${contacts.company} != ''
          THEN ${contacts.company}
        WHEN ${contacts.firstName} IS NOT NULL
          THEN TRIM(${contacts.firstName} || ' ' || COALESCE(${contacts.lastName}, ''))
        ELSE ''
      END
    `,
    vendorCompany: contacts.company,
  })
  .from(costs)
  .leftJoin(contacts, eq(costs.contactId, contacts.id))
// ... rest of query
```

**Priority Order:**

1. **Company name** (if exists and not empty string)
2. **FirstName + LastName** (trim to handle null lastName)
3. **Empty string** (if no vendor/contact)

**Edge Cases:**

- Company is empty string `''`: Treat as null, use firstName/lastName
- FirstName exists but lastName is null: Show "John" (not "John null")
- Both company and firstName are null: Show empty string in export
- Company is whitespace only: Trim and treat as empty

**Vendor Report CSV:**

```typescript
// For vendor report, show both fields separately
const vendorReport = {
  "Vendor Name": vendorName, // Company OR firstName lastName
  Company: vendorCompany || "N/A", // Explicit company field
  // ... other fields
}
```

#### 5. Export Filter Validation

**Problem:** Invalid filter values could cause query errors or unexpected results

**Implementation:**

```typescript
import { z } from "zod"

// Zod schema for export request
export const exportCostsSchema = z.object({
  projectId: z.string().uuid("Invalid project ID"),

  filters: z
    .object({
      dateRange: z
        .object({
          start: z.coerce.date().nullable(),
          end: z.coerce.date().nullable(),
        })
        .refine(
          (range) => {
            if (!range.start || !range.end) return true
            return range.start <= range.end
          },
          { message: "Start date must be before or equal to end date" }
        )
        .optional(),

      categoryIds: z.array(z.string().uuid()).max(50).optional(),
      contactIds: z.array(z.string().uuid()).max(50).optional(),
    })
    .optional(),

  format: z.enum(["csv", "excel"], {
    errorMap: () => ({ message: "Format must be 'csv' or 'excel'" }),
  }),
})

export type ExportCostsInput = z.infer<typeof exportCostsSchema>
```

**Error Handling:**

```typescript
// In tRPC procedure
exportCosts: protectedProcedure.input(exportCostsSchema).query(async ({ input, ctx }) => {
  // Check rate limit
  checkRateLimit(ctx.user.id)

  // Verify project access
  await verifyProjectOwnership(ctx.db, input.projectId, ctx.user.id)

  // Fetch costs with filters
  const costs = await fetchCostsForExport(ctx.db, input.projectId, input.filters)

  // Handle no results gracefully
  if (costs.length === 0) {
    // Don't throw error - return empty dataset
    // Client will show friendly message
    return { costs: [], message: "No costs found matching your filters" }
  }

  return { costs }
})
```

**Client-Side Handling:**

```typescript
const { data } = api.costs.exportCosts.useQuery(exportParams)

if (data && data.costs.length === 0) {
  toast.info("No costs found matching your filters. Try adjusting the date range or categories.")
  return
}

// Generate export file
const csv = generateCostsCsv(data.costs)
downloadCsv(csv, filename)
```

**Validation Errors:**

- Invalid date range: "Start date must be before end date"
- Invalid UUIDs: Zod automatically validates and rejects
- Too many IDs (>50): "Too many categories selected. Maximum 50."
- Invalid format: "Format must be 'csv' or 'excel'"

#### 6. Rate Limit Reset Calculation and Messaging

**Problem:** Users need clear messaging about when they can export again

**Implementation:**

```typescript
// Rate limiter with detailed error message
function checkRateLimit(userId: string): void {
  const now = Date.now()
  const oneHourAgo = now - 60 * 60 * 1000

  // Get user's export timestamps
  const userExports = exportCounts.get(userId) || []

  // Filter to last hour
  const recentExports = userExports.filter((ts) => ts > oneHourAgo)

  // Check limit
  if (recentExports.length >= 10) {
    const oldestExport = Math.min(...recentExports)
    const resetTime = oldestExport + 60 * 60 * 1000 // One hour from oldest
    const minutesUntilReset = Math.ceil((resetTime - now) / (60 * 1000))

    throw new TRPCError({
      code: "TOO_MANY_REQUESTS",
      message: `Export limit reached (10 per hour). You can export again in ${minutesUntilReset} minute${minutesUntilReset !== 1 ? "s" : ""}.`,
      cause: { resetTime, exportsRemaining: 0 },
    })
  }

  // Record this export
  recentExports.push(now)
  exportCounts.set(userId, recentExports)
}
```

**Client-Side Display:**

```typescript
const exportMutation = api.costs.exportCosts.useMutation({
  onError: (error) => {
    if (error.data?.code === "TOO_MANY_REQUESTS") {
      // Extract time from error message
      const match = error.message.match(/(\d+) minute/)
      const minutes = match ? match[1] : "60"

      toast.error(error.message, {
        duration: 5000,
        action: {
          label: "OK",
          onClick: () => {},
        },
      })
    } else {
      toast.error("Export failed. Please try again.")
    }
  },
})
```

**Optional Enhancement - Show Remaining Quota:**

```typescript
// Add to export dialog UI
const { data: quota } = api.costs.getExportQuota.useQuery()

// Show in UI:
// "Export Quota: 7/10 remaining this hour"
```

#### 7. Export Performance Targets and Optimization

**Problem:** Need specific performance targets and optimization strategy

**Performance Targets (from AC 9):**

```typescript
// Target completion times:
const PERFORMANCE_TARGETS = {
  small: { maxCosts: 100, targetTime: 1000 }, // <1 second
  medium: { maxCosts: 500, targetTime: 3000 }, // <3 seconds
  large: { maxCosts: 1000, targetTime: 10000 }, // <10 seconds
}

// Show warning for large exports
if (costCount > 500) {
  toast.info(`Generating large export (${costCount} costs). This may take up to 10 seconds...`, {
    duration: 3000,
  })
}
```

**Query Optimization:**

```typescript
async function fetchCostsForExport(
  db: Database,
  projectId: string,
  filters?: ExportFilters
): Promise<CostExportRecord[]> {
  // Optimization techniques:
  // 1. Select only needed fields (not SELECT *)
  // 2. Use existing indexes (projectId, date, categoryId, contactId)
  // 3. Filter in database (not JavaScript)
  // 4. Minimize joins (only necessary tables)

  const query = db
    .select({
      // Cost fields (only what's needed for export)
      id: costs.id,
      date: costs.date,
      description: costs.description,
      amount: costs.amount,
      notes: costs.notes,
      createdAt: costs.createdAt,

      // Joined fields
      categoryName: categories.id,
      categoryDisplayName: categories.displayName,
      vendorName: sql<string>`...`, // As defined in clarification 4
      vendorCompany: contacts.company,
      createdByName: sql<string>`${users.firstName} || ' ' || ${users.lastName}`,
      createdByEmail: users.email,
      projectName: projects.name,
    })
    .from(costs)
    .innerJoin(categories, eq(costs.categoryId, categories.id))
    .leftJoin(contacts, eq(costs.contactId, contacts.id))
    .innerJoin(users, eq(costs.createdById, users.id))
    .innerJoin(projects, eq(costs.projectId, projects.id))
    .where(
      and(
        eq(costs.projectId, projectId),
        isNull(costs.deletedAt),
        // Apply filters (database-side filtering)
        filters?.dateRange?.start ? gte(costs.date, filters.dateRange.start) : undefined,
        filters?.dateRange?.end ? lte(costs.date, filters.dateRange.end) : undefined,
        filters?.categoryIds?.length ? inArray(costs.categoryId, filters.categoryIds) : undefined,
        filters?.contactIds?.length ? inArray(costs.contactId, filters.contactIds) : undefined
      )
    )
    .orderBy(desc(costs.date)) // Most recent first

  // Execute query (database handles optimization)
  return await query
}
```

**Client-Side Performance:**

```typescript
// For Excel generation with large datasets, consider Web Worker
async function generateExcelInWorker(data: CostExportData): Promise<ArrayBuffer> {
  if (data.costs.length > 1000) {
    // Use Web Worker to avoid blocking UI
    const worker = new Worker("/workers/excel-generator.js")
    return new Promise((resolve) => {
      worker.postMessage(data)
      worker.onmessage = (e) => {
        resolve(e.data)
        worker.terminate()
      }
    })
  }

  // Small datasets: Generate directly
  return generateCostsExcel(data)
}
```

#### 8. Cross-Platform Excel Compatibility Testing

**Problem:** Need systematic approach to verify Excel files work across platforms

**Manual Testing Checklist:**

```markdown
## Excel Export Compatibility Testing

### Test File Generation

- [ ] Create test project with 100+ costs
- [ ] Include unicode data: Chinese (中文), Arabic (العربية), Emoji (😀)
- [ ] Include special characters in descriptions: quotes, commas, newlines
- [ ] Generate Excel export with all 3 sheets

### Microsoft Excel (Windows/Mac)

- [ ] Open file in Excel
- [ ] Verify: 3 sheets visible (Summary, Detailed Costs, Vendor Summary)
- [ ] Verify: Currency displays as $1,234.56
- [ ] Verify: Dates display as DD/MM/YYYY format
- [ ] Verify: Headers are bold
- [ ] Verify: Column widths are appropriate (no truncation)
- [ ] Verify: Freeze panes work (scroll down, header stays visible)
- [ ] Verify: Auto-filter enabled on Detailed Costs sheet
- [ ] Verify: Unicode characters display correctly
- [ ] Verify: Special characters display correctly

### Google Sheets

- [ ] Upload file to Google Drive
- [ ] Open in Google Sheets
- [ ] Verify: All 3 sheets accessible
- [ ] Verify: Currency formatting preserved
- [ ] Verify: Date formatting preserved
- [ ] Verify: Bold headers preserved
- [ ] Verify: Unicode characters display correctly
- [ ] Verify: Can edit and save without corruption

### Apple Numbers (Mac)

- [ ] Open file in Numbers
- [ ] Verify: All sheets accessible
- [ ] Verify: Currency and date formats correct
- [ ] Verify: Bold formatting preserved
- [ ] Verify: Unicode characters display correctly

### Performance Testing

- [ ] Generate export with 1000+ costs
- [ ] Measure time: Should be <10 seconds
- [ ] Verify: File opens successfully in all applications
- [ ] Verify: Large file doesn't cause application slowdown
```

**Common Compatibility Issues and Solutions:**

```typescript
// Issue 1: Date formats may display differently based on locale
// Solution: Use explicit date format string
sheet[cellRef].z = 'DD/MM/YYYY' // Explicit format

// Issue 2: Currency symbols may change based on system locale
// Solution: Use explicit currency format with $ symbol
sheet[cellRef].z = '$#,##0.00' // Explicit $ symbol

// Issue 3: Column widths may auto-adjust differently
// Solution: Set explicit column widths
sheet['!cols'] = [{ wch: 12 }, { wch: 30 }, ...] // Explicit widths

// Issue 4: Unicode characters may not display in older Excel versions
// Solution: Ensure UTF-8 encoding in export
const blob = new Blob([buffer], {
  type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8'
})
```

**Automated Compatibility Test:**

```typescript
// apps/web/src/lib/utils/__tests__/excel-export.test.ts
import { describe, it, expect } from "vitest"
import { generateCostsExcel } from "../excel-export"
import * as XLSX from "xlsx"

describe("Excel Export - Cross-Platform Compatibility", () => {
  it("generates valid Excel file that can be read back", () => {
    const testData = {
      costs: [
        /* test data with unicode */
      ],
      vendors: [
        /* test vendors */
      ],
      categoryTotals: [
        /* test totals */
      ],
      projectName: "Test Project 测试",
      dateRange: { start: new Date(), end: new Date() },
    }

    const buffer = generateCostsExcel(testData)

    // Verify buffer is valid Excel file
    expect(buffer).toBeInstanceOf(ArrayBuffer)
    expect(buffer.byteLength).toBeGreaterThan(0)

    // Read back and verify structure
    const workbook = XLSX.read(buffer, { type: "array" })
    expect(workbook.SheetNames).toEqual(["Summary", "Detailed Costs", "Vendor Summary"])

    // Verify unicode preservation
    const sheet = workbook.Sheets["Detailed Costs"]
    const range = XLSX.utils.decode_range(sheet["!ref"]!)
    const firstDataRow = XLSX.utils.sheet_to_json(sheet)[0] as any

    // Check that unicode characters are preserved
    expect(firstDataRow.Description).toContain("测试")
  })

  it("applies correct formatting that preserves across platforms", () => {
    const buffer = generateCostsExcel(testData)
    const workbook = XLSX.read(buffer, { type: "array" })
    const sheet = workbook.Sheets["Detailed Costs"]

    // Verify currency format
    const amountCell = sheet["C2"]
    expect(amountCell.z).toBe("$#,##0.00")

    // Verify date format
    const dateCell = sheet["A2"]
    expect(dateCell.z).toBe("DD/MM/YYYY")

    // Verify header formatting
    const headerCell = sheet["A1"]
    expect(headerCell.s?.font?.bold).toBe(true)
  })
})
```

---

**Implementation Checklist for Dev Agent:**

Before starting implementation, verify:

- [ ] Install `xlsx` library: `bun add xlsx`
- [ ] Verify TypeScript types included (or add @types/xlsx)
- [ ] Use ONLY SheetJS Community Edition features (no borders/background colors)
- [ ] Update AC 7 to remove "borders" requirement
- [ ] Implement export history using audit_logs table (no new table)
- [ ] Implement filename sanitization with fallback for edge cases
- [ ] Vendor name aggregation: Company > FirstName+LastName > Empty
- [ ] Rate limiting: Clear error messages with time remaining
- [ ] Export filter validation with Zod schema
- [ ] Performance optimization: Select only needed fields, use indexes
- [ ] Cross-platform testing: Manual checklist for Excel, Sheets, Numbers

Document any deviations or decisions in Dev Agent Record > Completion Notes section.

### Testing Strategy

[Source: [docs/architecture/testing-strategy.md](docs/architecture/testing-strategy.md)]

**Test Coverage:**

- Unit tests: CSV generation, Excel generation, rate limiting
- Backend tests: tRPC export procedures, query optimization, RBAC
- Component tests: ExportDialog, ExportHistory
- Integration tests: Complete export workflow
- Manual tests: Open exports in Excel/Sheets/Numbers

**Critical Test Scenarios:**

- CSV with unicode characters (Chinese, Arabic, emojis)
- CSV with special characters (quotes, commas, newlines)
- Excel with 1000+ rows (performance)
- Excel formatting in different applications
- Rate limiting enforcement and reset
- RBAC (export only accessible projects)

## Testing

### Test File Locations

**Backend Unit Tests:**

- `apps/web/src/server/api/routers/__tests__/cost-export.test.ts`

**Utility Tests:**

- `apps/web/src/lib/utils/__tests__/cost-export.test.ts`
- `apps/web/src/lib/utils/__tests__/excel-export.test.ts`

**Component Tests:**

- `apps/web/src/components/costs/__tests__/ExportDialog.test.tsx`
- `apps/web/src/components/costs/__tests__/ExportHistory.test.tsx`

**Integration Tests:**

- `apps/web/integration/api/__tests__/cost-export.spec.ts`

### Example Tests

**Backend Test Example:**

```typescript
import { describe, it, expect } from "vitest"
import { appRouter } from "../../../api/root"
import { createTestContext } from "@/test/test-db"

describe("cost.exportCosts", () => {
  it("exports 1000+ costs within 10 seconds", async () => {
    const ctx = await createTestContext()
    const caller = appRouter.createCaller(ctx)

    // Create test project with 1000 costs
    const project = await createTestProject(ctx)
    await seedCosts(ctx, project.id, 1000)

    // Execute export
    const startTime = Date.now()
    const result = await caller.costs.exportCosts({
      projectId: project.id,
      filters: {},
      format: "csv",
    })
    const endTime = Date.now()

    expect(result.costs.length).toBe(1000)
    expect(endTime - startTime).toBeLessThan(10000) // <10 seconds
  })

  it("enforces rate limiting (10 exports per hour)", async () => {
    const ctx = await createTestContext()
    const caller = appRouter.createCaller(ctx)

    // Execute 10 exports (should succeed)
    for (let i = 0; i < 10; i++) {
      await caller.costs.exportCosts({
        projectId: "test-project",
        filters: {},
        format: "csv",
      })
    }

    // 11th export should fail
    await expect(
      caller.costs.exportCosts({
        projectId: "test-project",
        filters: {},
        format: "csv",
      })
    ).rejects.toThrow(/rate limit/i)
  })

  it("respects RBAC (only exports accessible projects)", async () => {
    const ctx = await createTestContext({ userId: "unauthorized-user" })
    const caller = appRouter.createCaller(ctx)

    await expect(
      caller.costs.exportCosts({
        projectId: "other-user-project",
        filters: {},
        format: "csv",
      })
    ).rejects.toThrow(/forbidden/i)
  })
})
```

**CSV Export Test Example:**

```typescript
import { describe, it, expect } from "vitest"
import { generateCostsCsv, escapeCsvValue } from "../cost-export"

describe("cost-export", () => {
  it("handles unicode characters correctly", () => {
    const data = {
      costs: [
        {
          description: "中文描述", // Chinese
          amount: 150000,
          // ... other fields
        },
        {
          description: "Description with 😀 emoji",
          amount: 250000,
          // ... other fields
        },
      ],
      // ... other data
    }

    const csv = generateCostsCsv(data)

    expect(csv).toContain("中文描述")
    expect(csv).toContain("😀")
  })

  it("prevents formula injection", () => {
    expect(escapeCsvValue("=1+1")).toBe("'=1+1")
    expect(escapeCsvValue("+CMD|/C calc")).toBe("'+CMD|/C calc")
    expect(escapeCsvValue("@SUM(A1:A10)")).toBe("'@SUM(A1:A10)")
  })
})
```

**Excel Export Test Example:**

```typescript
import { describe, it, expect } from "vitest"
import { generateCostsExcel } from "../excel-export"
import * as XLSX from "xlsx"

describe("excel-export", () => {
  it("creates workbook with 3 sheets", () => {
    const data = {
      costs: mockCosts,
      vendors: mockVendors,
      categoryTotals: mockCategoryTotals,
      projectName: "Test Project",
      dateRange: { start: new Date(), end: new Date() },
    }

    const buffer = generateCostsExcel(data)
    const workbook = XLSX.read(buffer, { type: "array" })

    expect(workbook.SheetNames).toHaveLength(3)
    expect(workbook.SheetNames).toContain("Summary")
    expect(workbook.SheetNames).toContain("Detailed Costs")
    expect(workbook.SheetNames).toContain("Vendor Summary")
  })

  it("applies currency formatting to amount cells", () => {
    const data = {
      /* ... */
    }
    const buffer = generateCostsExcel(data)
    const workbook = XLSX.read(buffer, { type: "array" })
    const sheet = workbook.Sheets["Detailed Costs"]

    // Check cell C2 (first amount cell)
    const amountCell = sheet["C2"]
    expect(amountCell.z).toBe("$#,##0.00")
  })
})
```

### Manual Testing Checklist

- [ ] Export CSV, open in Excel - verify formatting and unicode
- [ ] Export CSV, open in Google Sheets - verify import works
- [ ] Export Excel, open in Microsoft Excel - verify all sheets and formatting
- [ ] Export Excel, open in Google Sheets - verify compatibility
- [ ] Export Excel, open in Apple Numbers - verify compatibility
- [ ] Export with 1000+ costs - verify performance (<10s)
- [ ] Trigger rate limit - verify error message and countdown
- [ ] Export with date range filter - verify correct costs included
- [ ] Export with category filter - verify correct costs included
- [ ] Export vendor report - verify aggregations correct

## Change Log

| Date       | Version | Description                                                                                                                                                                                                                                                                                                                                                               | Author     |
| ---------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| 2025-11-03 | 1.0     | Initial story creation                                                                                                                                                                                                                                                                                                                                                    | Bob        |
| 2025-11-03 | 1.1     | Added implementation clarifications for dev agent addressing missing requirements (SheetJS library limitations, export history storage, filename sanitization, vendor name aggregation, filter validation, rate limiting, performance optimization, cross-platform testing); Updated AC 7 to reflect SheetJS Community Edition capabilities (removed borders requirement) | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent_
