# Story 8.1: In-App Notification System

## Status

Approved

## Story

**As a** project owner or partner,
**I want** to receive in-app notifications for important project activities,
**so that** I stay informed about project updates without constant manual checking.

## Acceptance Criteria

1. [ ] Notifications table created with proper schema and indexes
2. [ ] Bell icon visible in header for all authenticated users
3. [ ] Unread count badge displays correct number
4. [ ] Notification panel opens on bell icon click
5. [ ] Notifications grouped by date with clear sections
6. [ ] Each notification shows icon, message, timestamp, read status
7. [ ] Clicking notification navigates to entity and marks as read
8. [ ] "Mark all as read" button works correctly
9. [ ] New notifications appear within 30 seconds (polling interval)
10. [ ] Notifications generated for all defined events
11. [ ] Large expense threshold ($10k) triggers immediate notification
12. [ ] Notification panel shows loading state during fetch
13. [ ] Empty state displayed when no notifications
14. [ ] Notifications respect RBAC (users only see their notifications)
15. [ ] Notification cleanup job removes old notifications (>90 days)

## Tasks / Subtasks

- [ ] Create notifications database schema (AC: 1)
  - [ ] Create Drizzle schema file: `apps/web/src/server/db/schema/notifications.ts`
  - [ ] Define `notifications` table with fields:
    - [ ] `id` (uuid, primary key)
    - [ ] `userId` (uuid, foreign key to users.id)
    - [ ] `type` (enum: cost_added, large_expense, document_uploaded, timeline_event, partner_invited, comment_added)
    - [ ] `entityType` (enum: cost, document, event, project)
    - [ ] `entityId` (uuid)
    - [ ] `projectId` (uuid, foreign key to projects.id)
    - [ ] `message` (text, notification message)
    - [ ] `read` (boolean, default false)
    - [ ] `createdAt` (timestamp, default now())
  - [ ] Create indexes:
    - [ ] `idx_notifications_user_id` on userId
    - [ ] `idx_notifications_user_read` on (userId, read) for unread queries
    - [ ] `idx_notifications_created_at` on createdAt for cleanup
  - [ ] Generate migration: `bunx drizzle-kit generate`
  - [ ] Apply migration: `bunx drizzle-kit push`

- [ ] Create tRPC notification router (AC: 7, 8, 9, 13, 14)
  - [ ] Create router file: `apps/web/src/server/api/routers/notification.ts`
  - [ ] Implement `list` query:
    - [ ] Input: limit (default 20), offset (for pagination)
    - [ ] Verify authentication (protected procedure)
    - [ ] Query notifications for ctx.user.id
    - [ ] Order by createdAt DESC (most recent first)
    - [ ] Include unread count in response
    - [ ] Return: { notifications: Notification[], unreadCount: number }
  - [ ] Implement `markAsRead` mutation:
    - [ ] Input: notificationId (single) or "all" flag
    - [ ] Verify notification belongs to ctx.user.id (RBAC)
    - [ ] Update read = true
    - [ ] Return: success boolean
  - [ ] Implement `markAllAsRead` mutation:
    - [ ] Update all unread notifications for ctx.user.id
    - [ ] Set read = true WHERE userId = ctx.user.id AND read = false
    - [ ] Return: count of updated notifications
  - [ ] Add router to root router in `apps/web/src/server/api/root.ts`
  - [ ] Unit tests for all procedures

- [ ] Create notification generation utility (AC: 10, 11)
  - [ ] Create utility file: `apps/web/src/server/utils/notifications.ts`
  - [ ] Implement `createNotification` function:
    - [ ] Parameters: userId, type, entityType, entityId, projectId, message
    - [ ] Insert into notifications table
    - [ ] Return created notification
  - [ ] Implement `notifyProjectMembers` function:
    - [ ] Query project owner and partners with access
    - [ ] Filter to users with acceptedAt not null
    - [ ] Create notification for each member (batch insert)
    - [ ] Return count of notifications created
  - [ ] Implement notification message templates:
    - [ ] cost_added: "{user} added a ${amount} cost: {description}"
    - [ ] large_expense: "ALERT: ${amount} large expense added: {description}"
    - [ ] document_uploaded: "{user} uploaded {fileName}"
    - [ ] timeline_event: "{user} created event: {title}"
    - [ ] partner_invited: "You've been invited to {projectName}"
    - [ ] comment_added: "{user} commented on {entityType}"
  - [ ] Unit tests for notification generation

- [ ] Integrate notification generation into existing mutations (AC: 10, 11)
  - [ ] **Cost creation** (`apps/web/src/server/api/routers/cost.ts`):
    - [ ] After successful cost insert, generate notifications
    - [ ] Check if amount >= $10,000 (10000 in cents = 1000000)
    - [ ] Use type 'large_expense' if threshold exceeded, else 'cost_added'
    - [ ] Notify all project members
  - [ ] **Document upload** (`apps/web/src/server/api/routers/document.ts`):
    - [ ] After successful upload, generate 'document_uploaded' notification
    - [ ] Notify all project members
  - [ ] **Timeline event creation** (`apps/web/src/server/api/routers/event.ts`):
    - [ ] After event creation, generate 'timeline_event' notification
    - [ ] Notify all project members
  - [ ] **Partner invitation** (`apps/web/src/server/api/routers/project.ts`):
    - [ ] After partner invitation, generate 'partner_invited' notification
    - [ ] Notify only the invited partner (single user)
  - [ ] Ensure all integrations are within transactions (rollback on failure)

- [ ] Create NotificationBell UI component (AC: 2, 3, 4)
  - [ ] Create component: `apps/web/src/components/notifications/NotificationBell.tsx`
  - [ ] Use Shadcn/ui Popover for dropdown panel
  - [ ] Bell icon with lucide-react: `<Bell className="h-5 w-5" />`
  - [ ] Unread count badge:
    - [ ] Position absolute top-right of bell icon
    - [ ] Background red (destructive color)
    - [ ] Show count if > 0, hide if 0
    - [ ] Max display: "99+" for counts > 99
  - [ ] Click bell icon to toggle NotificationPanel
  - [ ] Fetch unread count with React Query (polling: 30s)
  - [ ] Component tests

- [ ] Create NotificationPanel UI component (AC: 5, 6, 7, 8, 12, 13)
  - [ ] Create component: `apps/web/src/components/notifications/NotificationPanel.tsx`
  - [ ] Popover content structure:
    - [ ] Header: "Notifications" title + "Mark all as read" button
    - [ ] Body: Scrollable list of notifications (max-height: 400px)
    - [ ] Footer: "View all" link (future enhancement)
  - [ ] Group notifications by date:
    - [ ] "Today" - notifications from today
    - [ ] "Yesterday" - notifications from yesterday
    - [ ] "This Week" - notifications from this week
    - [ ] "Older" - notifications older than this week
  - [ ] Notification item component:
    - [ ] Icon based on notification type (lucide-react icons)
    - [ ] Message text (truncate if > 100 chars)
    - [ ] Timestamp (relative: "2 hours ago")
    - [ ] Read status indicator (blue dot for unread)
    - [ ] Click handler: navigate to entity + mark as read
  - [ ] Loading state: Skeleton loaders during fetch
  - [ ] Empty state: "No notifications yet" with icon
  - [ ] "Mark all as read" button:
    - [ ] Call markAllAsRead mutation
    - [ ] Show loading state during mutation
    - [ ] Optimistic update (mark all as read immediately)
    - [ ] Rollback on error
  - [ ] Component tests

- [ ] Implement React Query polling for real-time updates (AC: 9)
  - [ ] Configure notification list query with polling:
    - [ ] refetchInterval: 30000 (30 seconds)
    - [ ] refetchIntervalInBackground: true (poll even when tab inactive)
    - [ ] refetchOnWindowFocus: true (refetch when user returns to tab)
  - [ ] Configure unread count query with same polling settings
  - [ ] Use React Query devtools to verify polling behavior
  - [ ] Test: Add notification via different browser/user, verify appears within 30s

- [ ] Implement notification navigation (AC: 7)
  - [ ] Create navigation utility: `apps/web/src/lib/utils/notification-navigation.ts`
  - [ ] Map entityType to URL patterns:
    - [ ] 'cost' â†’ `/projects/[projectId]/costs/[entityId]`
    - [ ] 'document' â†’ `/projects/[projectId]/documents/[entityId]`
    - [ ] 'event' â†’ `/projects/[projectId]/timeline/[entityId]`
    - [ ] 'project' â†’ `/projects/[projectId]`
  - [ ] Implement `getNotificationUrl` function:
    - [ ] Input: notification object
    - [ ] Return: URL string for Next.js router
  - [ ] On notification click:
    - [ ] Call markAsRead mutation
    - [ ] Navigate using Next.js router.push()
    - [ ] Close notification panel
  - [ ] Unit tests for URL generation

- [ ] Integrate NotificationBell into Navbar header (AC: 2)
  - [ ] Edit header component: `apps/web/src/components/layout/Navbar.tsx`
  - [ ] Add NotificationBell import and component to header
  - [ ] Position: Right side of header, between Search button and UserDropdown (line 80-96 area)
  - [ ] Ensure visibility on mobile and desktop
  - [ ] Test responsive behavior at 375px, 768px, 1024px

- [ ] Implement notification cleanup job (AC: 15)
  - [ ] Create cleanup script: `apps/web/src/server/jobs/cleanup-notifications.ts`
  - [ ] Delete notifications WHERE createdAt < (now() - 90 days)
  - [ ] Log count of deleted notifications
  - [ ] Implement as API route: `apps/web/src/app/api/cron/cleanup-notifications/route.ts`
  - [ ] Use Netlify scheduled functions (or manual cron)
  - [ ] Schedule: Daily at 2 AM UTC
  - [ ] Add error handling and logging
  - [ ] Test manually by running cleanup script

- [ ] Write comprehensive tests (AC: 1-15)
  - [ ] Backend tests: `apps/web/src/server/api/routers/__tests__/notification.test.ts`
    - [ ] Test list query (authenticated user gets their notifications)
    - [ ] Test RBAC (user cannot see other users' notifications)
    - [ ] Test markAsRead (verify ownership check)
    - [ ] Test markAllAsRead (count verification)
    - [ ] Test notification generation (all event types)
    - [ ] Test large expense threshold ($10k detection)
  - [ ] Component tests: `apps/web/src/components/notifications/__tests__/`
    - [ ] NotificationBell.test.tsx (badge display, click behavior)
    - [ ] NotificationPanel.test.tsx (grouping, navigation, mark as read)
  - [ ] Integration tests:
    - [ ] Test: Create cost â†’ notification generated â†’ appears in list
    - [ ] Test: Upload document â†’ notification generated for all members
    - [ ] Test: Invite partner â†’ notification sent to partner only
    - [ ] Test: Click notification â†’ navigates correctly
  - [ ] E2E tests: `apps/web/e2e/tests/notifications.spec.ts`
    - [ ] Test full notification flow (create cost, see notification, click, navigate)
    - [ ] Test mark all as read functionality
    - [ ] Test polling (notification appears within 30s)

## Dev Notes

### Previous Story Insights

**From Story 7.2 (CSV Import - Complete):**

- Drizzle ORM transaction patterns working well for bulk operations
- React Query mutation patterns: optimistic updates, error handling, cache invalidation
- tRPC procedures use `verifyProjectOwnership` helper for RBAC consistency
- Zod validation schemas provide excellent runtime validation with clear error messages
- UI components follow Shadcn/ui patterns (Dialog, Button, Form components)
- Testing with Vitest: 144 tests passing, comprehensive coverage strategy working

**Key Takeaways:**

- Follow established tRPC procedure patterns (protectedProcedure, Zod input validation)
- Use React Query polling for real-time updates (proven pattern)
- Implement RBAC at database query level (filter by userId)
- Use Shadcn/ui components for consistency (Popover for notification panel)
- Co-locate tests with components (`__tests__/` subfolder)

### Tech Stack

[Source: [docs/architecture/tech-stack.md](docs/architecture/tech-stack.md)]

**Core Technologies:**

- Frontend: Next.js ^14.2.0, TypeScript ^5.3.0, React Query ^5.0.0
- UI: Shadcn/ui ^0.8.0, Tailwind CSS ^3.4.0
- Backend: tRPC ^10.45.0, Drizzle ORM ^0.44.6
- Database: Neon PostgreSQL (serverless)
- Validation: Zod ^3.22.0 for runtime validation
- Testing: Vitest ^1.6.0, Testing Library ^14.0.0, Playwright ^1.40.0

**Real-Time Updates:**

- React Query (TanStack Query) ^5.0.0 for polling
- Polling interval: 30 seconds (balances real-time feel with server load)
- Background polling enabled (updates even when tab inactive)

### Data Models

[Source: [docs/architecture/data-models.md](docs/architecture/data-models.md)]

**New Model: Notification**

```typescript
interface Notification {
  id: string // UUID
  userId: string // Foreign key to users.id
  type: NotificationType
  entityType: EntityType
  entityId: string // UUID of related entity
  projectId: string // Foreign key to projects.id
  message: string // Human-readable notification message
  read: boolean // Read status (default: false)
  createdAt: Date // Timestamp
}

type NotificationType =
  | "cost_added"
  | "large_expense"
  | "document_uploaded"
  | "timeline_event"
  | "partner_invited"
  | "comment_added"

type EntityType = "cost" | "document" | "event" | "project"
```

**Database Schema (Drizzle):**

```typescript
import { pgTable, uuid, varchar, text, boolean, timestamp, index } from "drizzle-orm/pg-core"
import { users } from "./users"
import { projects } from "./projects"

export const notificationTypeEnum = pgEnum("notification_type", [
  "cost_added",
  "large_expense",
  "document_uploaded",
  "timeline_event",
  "partner_invited",
  "comment_added",
])

export const notifications = pgTable(
  "notifications",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    userId: uuid("user_id")
      .notNull()
      .references(() => users.id),
    type: notificationTypeEnum("type").notNull(),
    entityType: varchar("entity_type", { length: 50 }).notNull(),
    entityId: uuid("entity_id").notNull(),
    projectId: uuid("project_id")
      .notNull()
      .references(() => projects.id),
    message: text("message").notNull(),
    read: boolean("read").notNull().default(false),
    createdAt: timestamp("created_at").notNull().defaultNow(),
  },
  (table) => ({
    userIdIdx: index("idx_notifications_user_id").on(table.userId),
    userReadIdx: index("idx_notifications_user_read").on(table.userId, table.read),
    createdAtIdx: index("idx_notifications_created_at").on(table.createdAt),
  })
)
```

**Architectural Decision - Soft Delete Pattern:**

The `notifications` table intentionally deviates from the BaseEntity soft delete pattern (no `deletedAt` field). Rationale:

- Notifications are ephemeral by design (90-day lifecycle)
- Hard delete via cleanup job is more efficient than soft delete
- No business need to "restore" deleted notifications
- Reduces database bloat for high-volume notification data
- Consistent with other time-series data patterns in the system

This architectural decision aligns with the cleanup strategy (AC 15) and optimizes for performance over data retention.

**Relationships:**

- Belongs to User (recipient)
- Belongs to Project
- References any entity through entityType/entityId

### API Patterns

[Source: [docs/architecture/coding-standards.md](docs/architecture/coding-standards.md#api--backend-standards)]

**tRPC Procedure Pattern:**

```typescript
import { TRPCError } from "@trpc/server"
import { z } from "zod"
import { createTRPCRouter, protectedProcedure } from "../trpc"

export const notificationRouter = createTRPCRouter({
  list: protectedProcedure
    .input(
      z.object({
        limit: z.number().min(1).max(100).default(20),
        offset: z.number().min(0).default(0),
      })
    )
    .query(async ({ input, ctx }) => {
      // RBAC: User can only see their own notifications
      const notifications = await ctx.db.query.notifications.findMany({
        where: eq(notifications.userId, ctx.user.id),
        orderBy: desc(notifications.createdAt),
        limit: input.limit,
        offset: input.offset,
      })

      const unreadCount = await ctx.db
        .select({ count: count() })
        .from(notifications)
        .where(and(eq(notifications.userId, ctx.user.id), eq(notifications.read, false)))

      return {
        notifications,
        unreadCount: unreadCount[0]?.count ?? 0,
      }
    }),

  markAsRead: protectedProcedure
    .input(z.object({ notificationId: z.string().uuid() }))
    .mutation(async ({ input, ctx }) => {
      // RBAC: Verify ownership before updating
      const notification = await ctx.db.query.notifications.findFirst({
        where: and(
          eq(notifications.id, input.notificationId),
          eq(notifications.userId, ctx.user.id)
        ),
      })

      if (!notification) {
        throw new TRPCError({ code: "NOT_FOUND" })
      }

      await ctx.db
        .update(notifications)
        .set({ read: true })
        .where(eq(notifications.id, input.notificationId))

      return { success: true }
    }),
})
```

### UI Component Patterns

[Source: [docs/architecture/components.md](docs/architecture/components.md), [docs/architecture/coding-standards.md](docs/architecture/coding-standards.md#component-patterns)]

**NotificationBell Component Pattern:**

```typescript
'use client'

import { useState } from 'react'
import { Bell } from 'lucide-react'
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'
import { Button } from '@/components/ui/button'
import { api } from '@/lib/trpc/client'
import { NotificationPanel } from './NotificationPanel'

export function NotificationBell() {
  const [open, setOpen] = useState(false)

  // Poll for unread count every 30 seconds
  const { data: unreadCount } = api.notification.list.useQuery(
    { limit: 1 },
    {
      select: (data) => data.unreadCount,
      refetchInterval: 30000, // 30 seconds
      refetchIntervalInBackground: true,
      refetchOnWindowFocus: true,
    }
  )

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button variant="ghost" size="icon" className="relative">
          <Bell className="h-5 w-5" />
          {(unreadCount ?? 0) > 0 && (
            <span className="absolute -top-1 -right-1 h-5 w-5 rounded-full bg-destructive text-[10px] font-medium text-destructive-foreground flex items-center justify-center">
              {unreadCount! > 99 ? '99+' : unreadCount}
            </span>
          )}
          <span className="sr-only">Notifications</span>
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-80 p-0" align="end">
        <NotificationPanel onClose={() => setOpen(false)} />
      </PopoverContent>
    </Popover>
  )
}
```

**React Query Polling Pattern:**

```typescript
// Polling configuration for real-time updates
const { data, isLoading } = api.notification.list.useQuery(
  { limit: 20, offset: 0 },
  {
    refetchInterval: 30000, // Poll every 30 seconds
    refetchIntervalInBackground: true, // Continue polling when tab inactive
    refetchOnWindowFocus: true, // Refetch when user returns to tab
    staleTime: 25000, // Data considered fresh for 25s
  }
)
```

### Project Structure

[Source: [docs/architecture/unified-project-structure.md](docs/architecture/unified-project-structure.md)]

**File Locations:**

```
apps/web/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ server/
â”‚   â”‚   â”œâ”€â”€ db/schema/
â”‚   â”‚   â”‚   â””â”€â”€ notifications.ts           # New notification schema
â”‚   â”‚   â”œâ”€â”€ api/routers/
â”‚   â”‚   â”‚   â”œâ”€â”€ notification.ts            # New notification router
â”‚   â”‚   â”‚   â”œâ”€â”€ cost.ts                    # Modify: Add notification generation
â”‚   â”‚   â”‚   â”œâ”€â”€ document.ts                # Modify: Add notification generation
â”‚   â”‚   â”‚   â”œâ”€â”€ event.ts                   # Modify: Add notification generation
â”‚   â”‚   â”‚   â””â”€â”€ project.ts                 # Modify: Add notification for partner invite
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â””â”€â”€ notifications.ts           # Notification generation utilities
â”‚   â”‚   â””â”€â”€ jobs/
â”‚   â”‚       â””â”€â”€ cleanup-notifications.ts   # Cleanup job (90-day expiry)
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â””â”€â”€ notifications/
â”‚   â”‚       â”œâ”€â”€ NotificationBell.tsx       # Bell icon + popover trigger
â”‚   â”‚       â”œâ”€â”€ NotificationPanel.tsx      # Notification list panel
â”‚   â”‚       â”œâ”€â”€ NotificationItem.tsx       # Individual notification component
â”‚   â”‚       â””â”€â”€ __tests__/                 # Component tests
â”‚   â”œâ”€â”€ lib/utils/
â”‚   â”‚   â””â”€â”€ notification-navigation.ts     # Entity URL mapping
â”‚   â”œâ”€â”€ app/api/cron/
â”‚   â”‚   â””â”€â”€ cleanup-notifications/
â”‚   â”‚       â””â”€â”€ route.ts                   # Cleanup cron endpoint
â”‚   â””â”€â”€ __tests__/                         # Co-located tests
```

### Notification Message Templates

**Message Format Strategy:**

```typescript
interface NotificationMessageParams {
  userName: string // User who triggered the action
  entityName?: string // Cost description, document name, event title
  amount?: number // For cost notifications (in cents)
  projectName?: string // For partner invitations
}

function generateNotificationMessage(
  type: NotificationType,
  params: NotificationMessageParams
): string {
  switch (type) {
    case "cost_added":
      return `${params.userName} added a ${formatCurrency(params.amount!)} cost: ${params.entityName}`

    case "large_expense":
      return `ðŸš¨ ALERT: ${formatCurrency(params.amount!)} large expense added: ${params.entityName}`

    case "document_uploaded":
      return `${params.userName} uploaded ${params.entityName}`

    case "timeline_event":
      return `${params.userName} created event: ${params.entityName}`

    case "partner_invited":
      return `You've been invited to ${params.projectName}`

    case "comment_added":
      return `${params.userName} commented on ${params.entityName}`

    default:
      return "New activity in your project"
  }
}
```

### Large Expense Threshold

**Threshold Definition:**

- Large expense: $10,000 or more
- Stored in cents: 1,000,000 cents = $10,000
- Check: `if (amount >= 1000000) { type = 'large_expense' }`

**Implementation:**

```typescript
// In cost creation mutation
const amount = input.amount // Already in cents

// Determine notification type based on threshold
const notificationType = amount >= 1000000 ? "large_expense" : "cost_added"

// Generate notification
await createNotification({
  type: notificationType,
  userId: projectMember.userId,
  entityType: "cost",
  entityId: newCost.id,
  projectId: input.projectId,
  message: generateNotificationMessage(notificationType, {
    userName: ctx.user.firstName,
    entityName: input.description,
    amount: amount,
  }),
})
```

### Notification Grouping Logic

**Library Dependency:**

```bash
# Verify date-fns is installed (confirmed: already in package.json v4.1.0)
# Used in Story 7.2, available for this story
grep "date-fns" apps/web/package.json

# If not present in future, install:
# bun add date-fns
```

**Date Grouping:**

```typescript
import { format, isToday, isYesterday, isThisWeek } from "date-fns"

type NotificationGroup = "Today" | "Yesterday" | "This Week" | "Older"

function groupNotificationsByDate(
  notifications: Notification[]
): Record<NotificationGroup, Notification[]> {
  return notifications.reduce(
    (groups, notification) => {
      const date = new Date(notification.createdAt)

      let group: NotificationGroup
      if (isToday(date)) {
        group = "Today"
      } else if (isYesterday(date)) {
        group = "Yesterday"
      } else if (isThisWeek(date)) {
        group = "This Week"
      } else {
        group = "Older"
      }

      if (!groups[group]) {
        groups[group] = []
      }
      groups[group].push(notification)

      return groups
    },
    {} as Record<NotificationGroup, Notification[]>
  )
}
```

### RBAC Enforcement

[Source: [docs/architecture/coding-standards.md](docs/architecture/coding-standards.md#security-standards)]

**Critical RBAC Rules:**

1. Users can only see their own notifications (filter by userId)
2. Users can only mark their own notifications as read (verify ownership)
3. Notifications generated only for project members with access
4. Partner notifications require acceptedAt != null

**Implementation:**

```typescript
// In notification list query
const notifications = await ctx.db.query.notifications.findMany({
  where: eq(notifications.userId, ctx.user.id), // RBAC: User's notifications only
  // ...
})

// In markAsRead mutation
const notification = await ctx.db.query.notifications.findFirst({
  where: and(
    eq(notifications.id, input.notificationId),
    eq(notifications.userId, ctx.user.id) // RBAC: Verify ownership
  ),
})

if (!notification) {
  throw new TRPCError({ code: "NOT_FOUND" }) // Or FORBIDDEN if distinguishing
}
```

### XSS Prevention

**Notification Messages:**

- Notification messages contain user-generated content (userNames, descriptions, cost amounts)
- React automatically escapes JSX content, preventing XSS in UI rendering
- No additional sanitization needed for display
- Database queries use parameterized statements via Drizzle ORM (SQL injection prevented)

**Critical:** Do NOT use `dangerouslySetInnerHTML` in notification components

### Notification Cleanup Strategy

**Cleanup Policy:**

- Delete notifications older than 90 days
- Run daily at 2 AM UTC
- Use Netlify scheduled functions or manual cron

**Implementation:**

```typescript
// apps/web/src/server/jobs/cleanup-notifications.ts
import { db } from "../db"
import { notifications } from "../db/schema/notifications"
import { lt, sql } from "drizzle-orm"

export async function cleanupOldNotifications(): Promise<number> {
  const ninetyDaysAgo = new Date()
  ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90)

  const result = await db
    .delete(notifications)
    .where(lt(notifications.createdAt, ninetyDaysAgo))
    .returning({ id: notifications.id })

  console.log(`Deleted ${result.length} notifications older than 90 days`)

  return result.length
}
```

**Cron Endpoint:**

```typescript
// apps/web/src/app/api/cron/cleanup-notifications/route.ts
import { NextResponse } from "next/server"
import { cleanupOldNotifications } from "@/server/jobs/cleanup-notifications"

export async function GET(request: Request) {
  // Optional: Verify cron secret from Netlify
  const authHeader = request.headers.get("authorization")
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  try {
    const deletedCount = await cleanupOldNotifications()
    return NextResponse.json({ success: true, deletedCount })
  } catch (error) {
    console.error("Notification cleanup failed:", error)
    return NextResponse.json({ error: "Cleanup failed" }, { status: 500 })
  }
}
```

### Testing Strategy

[Source: [docs/architecture/testing-strategy.md](docs/architecture/testing-strategy.md)]

**Test Coverage Requirements:**

**Backend Unit Tests:**

- Notification list query (RBAC enforcement)
- Mark as read mutation (ownership verification)
- Mark all as read mutation (count verification)
- Notification generation utility (all event types)
- Large expense threshold detection
- Notification cleanup job

**Component Tests:**

- NotificationBell: Badge display, unread count, click behavior
- NotificationPanel: Grouping, empty state, loading state, mark all as read
- NotificationItem: Click navigation, read status indicator

**Integration Tests:**

- Cost creation â†’ notification generated â†’ appears in list
- Document upload â†’ notifications for all project members
- Partner invitation â†’ notification to invited user only
- Notification click â†’ navigation + mark as read

**E2E Tests:**

- Full notification flow (trigger event, see notification, click, navigate)
- Polling (notification appears within 30 seconds)
- Mark all as read functionality

**Test Example:**

```typescript
// apps/web/src/server/api/routers/__tests__/notification.test.ts
import { describe, it, expect } from "vitest"
import { appRouter } from "../root"
import { createTestContext } from "@/test/test-db"

describe("notification.list", () => {
  it("returns notifications for authenticated user only (RBAC)", async () => {
    const ctx = await createTestContext()
    const caller = appRouter.createCaller(ctx)

    // Create notifications for different users
    const userNotification = await createNotification({ userId: ctx.user.id })
    const otherNotification = await createNotification({ userId: "other-user-id" })

    const result = await caller.notification.list({ limit: 10, offset: 0 })

    expect(result.notifications).toHaveLength(1)
    expect(result.notifications[0].id).toBe(userNotification.id)
    expect(result.notifications).not.toContainEqual(
      expect.objectContaining({ id: otherNotification.id })
    )
  })

  it("detects large expense threshold ($10k)", async () => {
    const ctx = await createTestContext()

    // Create cost with $15,000 (1,500,000 cents)
    const largeCost = await ctx.db.insert(costs).values({
      amount: 1500000, // $15,000
      projectId: "test-project",
      // ... other fields
    })

    // Generate notification
    const notificationType = largeCost.amount >= 1000000 ? "large_expense" : "cost_added"

    expect(notificationType).toBe("large_expense")
  })
})
```

### Responsive Design

[Source: [docs/architecture/coding-standards.md](docs/architecture/coding-standards.md#responsive-design-mobile-first)]

**Mobile (375px+):**

- Bell icon: 44x44px touch target
- Notification panel: Full-width dropdown below header
- Notification items: Stack vertically with adequate spacing

**Tablet (768px+):**

- Notification panel: Fixed width (320px), right-aligned

**Desktop (1024px+):**

- Notification panel: Fixed width (400px), right-aligned

### Performance Considerations

**Polling Optimization:**

- Interval: 30 seconds (balance between real-time and server load)
- Background polling: Enabled (updates even when tab inactive)
- Window focus refetch: Enabled (immediate update when user returns)
- Stale time: 25 seconds (prevents redundant fetches)

**Query Optimization:**

- Index on (userId, read) for fast unread count queries
- Index on createdAt for efficient date-based ordering
- Limit query results (default: 20 notifications)
- Use pagination for older notifications

**Database Indexes:**

```sql
CREATE INDEX idx_notifications_user_id ON notifications(user_id);
CREATE INDEX idx_notifications_user_read ON notifications(user_id, read);
CREATE INDEX idx_notifications_created_at ON notifications(created_at);
```

## Change Log

| Date       | Version | Description                                                                                                                                                                                                                                                                                                | Author     |
| ---------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| 2025-11-03 | 1.0     | Initial story creation                                                                                                                                                                                                                                                                                     | Bob        |
| 2025-11-03 | 1.1     | Added PO validation clarifications: Navbar component file path specification (apps/web/src/components/layout/Navbar.tsx), XSS prevention guidance for notification messages, date-fns dependency verification (confirmed v4.1.0 in package.json), soft delete pattern architectural decision documentation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent_
