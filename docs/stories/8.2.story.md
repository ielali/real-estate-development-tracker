# Story 8.2: Email Notifications with User Preferences

## Status

Approved

## Story

**As a** project owner or partner,
**I want** to configure email notifications for project activities based on my preferences,
**so that** I stay informed via email without being overwhelmed by notifications and can control how often I receive updates.

## Acceptance Criteria

1. [ ] Notification preferences table created with default values
2. [ ] Notification settings page accessible from user menu
3. [ ] All preference toggles work with immediate save
4. [ ] Digest frequency selection persists correctly
5. [ ] Email templates designed and tested in Resend
6. [ ] Emails include project name, entity description, and direct link
7. [ ] Large expense emails sent immediately regardless of digest setting
8. [ ] Daily digests sent at 8 AM user's timezone
9. [ ] Weekly digests sent Monday 8 AM user's timezone
10. [ ] Unsubscribe link works and updates preferences
11. [ ] Rate limiting enforced (10 immediate emails/hour)
12. [ ] Email queue processes digests on schedule
13. [ ] Email delivery tracked and logged
14. [ ] Failed emails retried (up to 3 attempts)
15. [ ] Emails tested across clients (Gmail, Outlook, Apple Mail)
16. [ ] Email content is mobile-responsive

## Tasks / Subtasks

- [ ] Create notification_preferences database schema (AC: 1)
  - [ ] Create Drizzle schema file: `apps/web/src/server/db/schema/notification_preferences.ts`
  - [ ] Define `notification_preferences` table with fields:
    - [ ] `userId` (text, primary key, foreign key to users.id)
    - [ ] `emailOnCost` (boolean, default true)
    - [ ] `emailOnLargeExpense` (boolean, default true)
    - [ ] `emailOnDocument` (boolean, default true)
    - [ ] `emailOnTimeline` (boolean, default true)
    - [ ] `emailOnComment` (boolean, default true)
    - [ ] `emailDigestFrequency` (enum: immediate, daily, weekly, never, default immediate)
    - [ ] `timezone` (text, default "Australia/Sydney")
    - [ ] `updatedAt` (timestamp, default now())
  - [ ] Create index on userId for fast lookups
  - [ ] Generate migration: `bunx drizzle-kit generate`
  - [ ] Apply migration: `bunx drizzle-kit push`

- [ ] Create tRPC notification preferences router (AC: 2, 3, 4)
  - [ ] Create router file: `apps/web/src/server/api/routers/notification_preferences.ts`
  - [ ] Implement `getPreferences` query:
    - [ ] Input: none (uses ctx.user.id)
    - [ ] Verify authentication (protected procedure)
    - [ ] Query preferences for ctx.user.id
    - [ ] Create default preferences if none exist
    - [ ] Return: NotificationPreferences object
  - [ ] Implement `updatePreferences` mutation:
    - [ ] Input: Partial<NotificationPreferences> (Zod validation)
    - [ ] Verify authentication
    - [ ] Update preferences for ctx.user.id
    - [ ] Use upsert pattern (insert if not exists, update if exists)
    - [ ] Return: updated NotificationPreferences
  - [ ] Add router to root router in `apps/web/src/server/api/root.ts`
  - [ ] Unit tests for all procedures

- [ ] Create notification settings page (AC: 2, 3, 4)
  - [ ] Create page: `apps/web/src/app/settings/notifications/page.tsx`
  - [ ] Page structure:
    - [ ] Header: "Notification Settings"
    - [ ] Description: "Manage how you receive notifications"
    - [ ] Section 1: Email Notification Types (toggle switches)
    - [ ] Section 2: Digest Frequency (radio buttons)
    - [ ] Section 3: Timezone Selection (select dropdown)
    - [ ] Save button with loading state
  - [ ] Use Shadcn/ui components:
    - [ ] Switch for toggle controls
    - [ ] Radio Group for digest frequency
    - [ ] Select for timezone
    - [ ] Button for save action
  - [ ] Implement React Query mutation for saving:
    - [ ] Optimistic updates (immediate UI response)
    - [ ] Success toast notification
    - [ ] Error handling with rollback
  - [ ] Component tests for all interactive elements

- [ ] Add settings navigation link (AC: 2)
  - [ ] Add "Notification Settings" to user dropdown menu
  - [ ] Route to `/settings/notifications`
  - [ ] Icon: Bell icon (lucide-react)

- [ ] Create email template system (AC: 5, 6)
  - [ ] Extend EmailService class in `apps/web/src/lib/email.ts`
  - [ ] Add method: `sendCostAddedEmail(data: CostEmailData)`
  - [ ] Add method: `sendLargeExpenseEmail(data: LargeExpenseEmailData)`
  - [ ] Add method: `sendDocumentUploadedEmail(data: DocumentEmailData)`
  - [ ] Add method: `sendTimelineEventEmail(data: TimelineEventEmailData)`
  - [ ] Add method: `sendCommentAddedEmail(data: CommentEmailData)`
  - [ ] Add method: `sendDailyDigestEmail(data: DailyDigestData)`
  - [ ] Add method: `sendWeeklyDigestEmail(data: WeeklyDigestData)`
  - [ ] Each method includes:
    - [ ] HTML template (responsive design)
    - [ ] Plain text version
    - [ ] Project name in subject
    - [ ] Entity description in body
    - [ ] Direct link to entity
    - [ ] Unsubscribe link in footer
  - [ ] Use consistent email styling (match existing templates)

- [ ] Integrate email sending into notification generation (AC: 6, 7)
  - [ ] Update `createNotification` in `apps/web/src/server/services/notifications.ts`:
    - [ ] After creating in-app notification, check user preferences
    - [ ] If `emailDigestFrequency === 'immediate'`, send email immediately
    - [ ] If `emailOnLargeExpense === true` AND notification type is `large_expense`, send immediate email (AC #7)
    - [ ] If digest mode (daily/weekly), add to queue (not immediate)
    - [ ] If `emailDigestFrequency === 'never'`, skip email
  - [ ] Respect individual notification type preferences (emailOnCost, emailOnDocument, etc.)
  - [ ] Use fire-and-forget pattern (don't fail transaction if email fails)
  - [ ] Log email errors but don't throw

- [ ] Implement email rate limiting (AC: 11)
  - [ ] Create rate limiter utility: `apps/web/src/server/utils/email-rate-limiter.ts`
  - [ ] Use in-memory cache (Map) with user ID as key
  - [ ] Track email count per user per hour
  - [ ] Limit: 10 immediate emails per hour per user
  - [ ] Reset counter after 1 hour
  - [ ] Skip rate limiting for large expense emails (critical)
  - [ ] Return boolean: `canSendEmail(userId: string): boolean`
  - [ ] Unit tests for rate limiting logic

- [ ] Create email delivery tracking (AC: 13, 14)
  - [ ] Create `email_logs` table schema:
    - [ ] `id` (uuid, primary key)
    - [ ] `userId` (text, foreign key to users.id)
    - [ ] `notificationId` (uuid, nullable, foreign key to notifications.id)
    - [ ] `emailType` (enum: cost_added, large_expense, document_uploaded, etc.)
    - [ ] `recipientEmail` (text)
    - [ ] `subject` (text)
    - [ ] `status` (enum: sent, delivered, failed, bounced)
    - [ ] `resendId` (text, nullable, Resend message ID)
    - [ ] `attempts` (integer, default 1)
    - [ ] `lastError` (text, nullable)
    - [ ] `sentAt` (timestamp)
    - [ ] `deliveredAt` (timestamp, nullable)
  - [ ] Generate and apply migration
  - [ ] Create helper function: `logEmailSent(data: EmailLogData)`
  - [ ] Create retry mechanism: `retryFailedEmails()` (up to 3 attempts)
  - [ ] Add index on userId and status for queries

- [ ] Implement digest email queue system (AC: 8, 9, 12)
  - [ ] Create digest queue table schema:
    - [ ] `id` (uuid, primary key)
    - [ ] `userId` (text, foreign key to users.id)
    - [ ] `notificationId` (uuid, foreign key to notifications.id)
    - [ ] `digestType` (enum: daily, weekly)
    - [ ] `scheduledFor` (timestamp)
    - [ ] `processed` (boolean, default false)
    - [ ] `processedAt` (timestamp, nullable)
    - [ ] `createdAt` (timestamp)
  - [ ] Generate and apply migration
  - [ ] Verify timezone handling library:
    - [ ] Check if date-fns v4.1.0 includes timezone support (likely via `format` with `timeZone` option)
    - [ ] If not, install date-fns-tz: `bun add date-fns-tz`
    - [ ] Test timezone conversion: "What time is 8 AM in user's timezone right now?"
  - [ ] Create function: `queueForDigest(userId, notificationId, digestType)`
  - [ ] Create cron job script: `apps/web/scripts/process-digests.ts`
  - [ ] Job logic:
    - [ ] Query all users with daily digest enabled (where emailDigestFrequency = 'daily')
    - [ ] For each user, get unprocessed notifications for last 24 hours
    - [ ] Group notifications by project
    - [ ] Send daily digest email
    - [ ] Mark notifications as processed
    - [ ] Log email delivery
  - [ ] Handle timezones (use user's timezone preference)
  - [ ] Schedule: Daily at 8 AM user's timezone (AC #8)
  - [ ] Schedule: Weekly on Monday 8 AM user's timezone (AC #9)
  - [ ] Implement as Netlify scheduled function (primary approach)
  - [ ] Can be triggered manually via: `bun run scripts/process-digests.ts --type daily` (fallback/testing)

- [ ] Add unsubscribe functionality (AC: 10)
  - [ ] Create unsubscribe page: `apps/web/src/app/unsubscribe/[token]/page.tsx`
  - [ ] Generate unsubscribe token using better-auth JWT utilities:
    - [ ] Use better-auth's existing JWT implementation (already in project)
    - [ ] Token payload: `{ userId: string, purpose: 'unsubscribe' }`
    - [ ] Token expiry: 90 days (matching notification cleanup period)
    - [ ] Secret: Use existing `BETTER_AUTH_SECRET` environment variable
    - [ ] Generate token when creating email (one-time use recommended)
  - [ ] Include unsubscribe link in all email footers: `${APP_URL}/unsubscribe/${token}`
  - [ ] On unsubscribe page:
    - [ ] Decode and verify JWT token using better-auth utilities
    - [ ] Handle expired/invalid tokens with clear error message
    - [ ] Extract userId from verified token
    - [ ] Show confirmation: "Unsubscribe from all emails?"
    - [ ] Offer options:
      - [ ] Turn off all emails (set emailDigestFrequency = 'never')
      - [ ] Manage preferences (link to `/settings/notifications`)
    - [ ] Update preferences on confirmation
    - [ ] Show success message

- [ ] Write comprehensive tests (AC: 1-16)
  - [ ] Backend tests: `apps/web/src/server/api/routers/__tests__/notification_preferences.test.ts`
    - [ ] Test getPreferences (creates defaults if not exist)
    - [ ] Test updatePreferences (upsert pattern)
    - [ ] Test RBAC (user can only update own preferences)
  - [ ] Email template tests:
    - [ ] Test all 7 email types render correctly
    - [ ] Test unsubscribe link present in all emails
    - [ ] Test direct entity links correct
  - [ ] Rate limiter tests:
    - [ ] Test 10 emails/hour limit
    - [ ] Test counter reset after 1 hour
    - [ ] Test large expense emails bypass limit
  - [ ] Digest queue tests:
    - [ ] Test queueForDigest adds to queue
    - [ ] Test processDigests sends emails
    - [ ] Test timezone handling (daily at 8 AM user time)
  - [ ] Component tests: `apps/web/src/app/settings/notifications/__tests__/`
    - [ ] NotificationSettingsPage.test.tsx (toggles, save, optimistic updates)
  - [ ] Integration tests:
    - [ ] Test: Create cost → check preferences → send email OR queue for digest
    - [ ] Test: Update preferences → immediate save → toast notification
    - [ ] Test: Unsubscribe → preferences updated to 'never'
  - [ ] E2E tests: `apps/web/e2e/tests/notification-settings.spec.ts`
    - [ ] Test full settings flow (update preferences, verify save)
    - [ ] Test unsubscribe flow

## Dev Notes

### Previous Story Insights

**From Story 8.1 (In-App Notifications - Complete):**

- Notification generation utilities working well (`notifications.ts` service)
- tRPC router patterns established (protectedProcedure, Zod validation)
- In-app notification system fully implemented (database, router, UI)
- Email integration already present in project (Resend service)
- React Query mutation patterns with optimistic updates proven effective
- RBAC enforcement at database query level (filter by userId)

**Key Takeaways:**

- Extend existing notification generation to include email sending
- Follow established tRPC procedure patterns
- Use fire-and-forget pattern for email sending (don't fail transactions)
- Implement RBAC at query level (user preferences scoped to ctx.user.id)
- Use Shadcn/ui components for settings page consistency

### Tech Stack

[Source: [docs/architecture/tech-stack.md](docs/architecture/tech-stack.md)]

**Core Technologies:**

- Frontend: Next.js ^14.2.0, TypeScript ^5.3.0, React Query ^5.0.0
- UI: Shadcn/ui ^0.8.0, Tailwind CSS ^3.4.0
- Backend: tRPC ^10.45.0, Drizzle ORM ^0.44.6
- Database: Neon PostgreSQL (serverless)
- Validation: Zod ^3.22.0 for runtime validation
- Testing: Vitest ^1.6.0, Testing Library ^14.0.0, Playwright ^1.40.0
- **Email Service: Resend ^3.2.0** (transactional email delivery)

**Email Service Configuration:**

- Environment variables:
  - `RESEND_API_KEY` - API key for Resend
  - `RESEND_FROM_EMAIL` - From email address (default: "onboarding@resend.dev")
  - `NEXT_PUBLIC_APP_URL` - Application URL for email links
- Development mode: Emails logged to console instead of sending
- Production mode: Emails sent via Resend API

### Data Models

[Source: [docs/architecture/data-models.md](docs/architecture/data-models.md)]

**New Model: NotificationPreferences**

```typescript
interface NotificationPreferences {
  userId: string // Primary key, foreign key to users.id
  emailOnCost: boolean // Email for cost added events
  emailOnLargeExpense: boolean // Email for large expense events
  emailOnDocument: boolean // Email for document uploaded events
  emailOnTimeline: boolean // Email for timeline events
  emailOnComment: boolean // Email for comment added events (Story 8.3)
  emailDigestFrequency: DigestFrequency // How often to batch emails
  timezone: string // User's timezone for digest scheduling (IANA timezone string)
  updatedAt: Date // Last update timestamp
}

type DigestFrequency = "immediate" | "daily" | "weekly" | "never"
```

**Database Schema (Drizzle):**

```typescript
import { pgTable, text, boolean, timestamp } from "drizzle-orm/pg-core"
import { users } from "./users"

export const DigestFrequencyEnum = {
  IMMEDIATE: "immediate",
  DAILY: "daily",
  WEEKLY: "weekly",
  NEVER: "never",
} as const

export type DigestFrequency = (typeof DigestFrequencyEnum)[keyof typeof DigestFrequencyEnum]

export const notificationPreferences = pgTable("notification_preferences", {
  userId: text("user_id")
    .primaryKey()
    .references(() => users.id, { onDelete: "cascade" }),
  emailOnCost: boolean("email_on_cost").notNull().default(true),
  emailOnLargeExpense: boolean("email_on_large_expense").notNull().default(true),
  emailOnDocument: boolean("email_on_document").notNull().default(true),
  emailOnTimeline: boolean("email_on_timeline").notNull().default(true),
  emailOnComment: boolean("email_on_comment").notNull().default(true),
  emailDigestFrequency: text("email_digest_frequency").notNull().default("immediate"),
  timezone: text("timezone").notNull().default("Australia/Sydney"),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
})
```

**Email Log Model:**

```typescript
interface EmailLog {
  id: string // UUID
  userId: string // Foreign key to users.id
  notificationId: string | null // Foreign key to notifications.id
  emailType: NotificationType
  recipientEmail: string
  subject: string
  status: EmailStatus
  resendId: string | null // Resend message ID for tracking
  attempts: number // Retry count
  lastError: string | null // Error message if failed
  sentAt: Date
  deliveredAt: Date | null
}

type EmailStatus = "sent" | "delivered" | "failed" | "bounced"
```

**Digest Queue Model:**

```typescript
interface DigestQueueEntry {
  id: string // UUID
  userId: string // Foreign key to users.id
  notificationId: string // Foreign key to notifications.id
  digestType: "daily" | "weekly"
  scheduledFor: Date // When to send digest
  processed: boolean // Whether digest was sent
  processedAt: Date | null
  createdAt: Date
}
```

### Email Service Integration

[Source: [apps/web/src/lib/email.ts](apps/web/src/lib/email.ts)]

**Existing EmailService Class:**

- Located at: `apps/web/src/lib/email.ts`
- Singleton instance: `export const emailService = new EmailService()`
- Base method: `sendEmail({ to, subject, html, text })`
- Development mode: Logs emails to console (no actual sending)
- Production mode: Sends via Resend API
- Error handling: Throws error on failure (catch in calling code)

**Existing Template Methods:**

- `sendPasswordResetEmail(data: PasswordResetEmailData)` - Password reset flow
- `sendInvitationEmail(data: InvitationEmailData)` - Partner invitation
- `send2FANotification(data: TwoFactorEmailData)` - 2FA state changes
- `sendBackupCodeUsedEmail(...)` - Security alert
- `sendBackupDownloadedEmail(...)` - Project backup notification

**Template Pattern (HTML + Text):**

- Each email type has two methods:
  - `private generateXXXHTML(...)` - Responsive HTML template
  - `private generateXXXText(...)` - Plain text version
- HTML templates use inline CSS for email client compatibility
- Consistent styling:
  - Gradient header (purple/blue)
  - White content area with padding
  - Gray footer with disclaimers
  - Responsive design (max-width: 600px)
  - Mobile-optimized (font sizes, padding, buttons)

**Email Footer Pattern:**

```html
<div class="footer">
  <p>This email was sent from Real Estate Portfolio</p>
  <p>You received this email because you are a member of this project.</p>
  <p><a href="${unsubscribeUrl}">Unsubscribe from these emails</a></p>
</div>
```

### Notification Integration Strategy

**Current Notification Generation (Story 8.1):**

File: `apps/web/src/server/services/notifications.ts`

Functions:

- `createNotification()` - Single notification creation
- `notifyProjectMembers()` - Batch notifications for project members
- `notifyCostAdded()`, `notifyLargeExpense()`, etc. - Convenience functions

**Email Integration Points:**

1. **Immediate Emails:**
   - After `createNotification()` or `notifyProjectMembers()`
   - Check user preferences: `emailDigestFrequency === 'immediate'`
   - Check notification type preference: `emailOnCost`, `emailOnLargeExpense`, etc.
   - Send email via `emailService.sendXXXEmail()`
   - Use fire-and-forget pattern (wrap in try/catch, log errors)

2. **Large Expense Override (AC #7):**
   - If notification type is `large_expense`
   - Send immediate email regardless of digest preference
   - Still respect `emailOnLargeExpense` toggle

3. **Digest Emails:**
   - If `emailDigestFrequency === 'daily'` or `'weekly'`
   - Add notification to digest queue
   - Process queue via cron job at scheduled times

**Fire-and-Forget Pattern:**

```typescript
// After creating in-app notification
try {
  const preferences = await getUserPreferences(userId)

  if (shouldSendImmediateEmail(notificationType, preferences)) {
    await emailService.sendCostAddedEmail({ ... })
    await logEmailSent({ ... })
  } else if (shouldQueueForDigest(preferences)) {
    await queueForDigest(userId, notificationId, preferences.emailDigestFrequency)
  }
} catch (error) {
  console.error("Failed to send email notification:", error)
  // Don't throw - notification already created successfully
}
```

### Rate Limiting Strategy

**Requirement:** Max 10 immediate emails per hour per user (AC #11)

**Implementation Approach:**

- In-memory Map with user ID as key
- Value: `{ count: number, resetAt: Date }`
- Increment count on each email
- Reset count after 1 hour
- Exception: Large expense emails bypass rate limit

**Rate Limiter Interface:**

```typescript
class EmailRateLimiter {
  private limits = new Map<string, { count: number; resetAt: Date }>()

  canSendEmail(userId: string, isLargeExpense = false): boolean {
    if (isLargeExpense) return true // Bypass for critical emails

    const limit = this.limits.get(userId)
    const now = new Date()

    if (!limit || now > limit.resetAt) {
      // Reset or initialize
      this.limits.set(userId, { count: 1, resetAt: new Date(now.getTime() + 3600000) })
      return true
    }

    if (limit.count >= 10) {
      return false // Rate limit exceeded
    }

    limit.count++
    return true
  }
}

export const emailRateLimiter = new EmailRateLimiter()
```

### Digest Email Processing

**Scheduling Requirements:**

- **Daily Digests:** Send at 8 AM user's timezone (AC #8)
- **Weekly Digests:** Send Monday 8 AM user's timezone (AC #9)

**Cron Job Strategy:**

- Script: `apps/web/scripts/process-digests.ts`
- Can be run manually: `bun run scripts/process-digests.ts --type daily`
- Can be scheduled via:
  - Netlify scheduled functions
  - GitHub Actions cron workflow
  - External cron service (cron-job.org)

**Timezone Handling:**

- User's timezone stored in `notificationPreferences.timezone`
- Use IANA timezone strings (e.g., "Australia/Sydney", "America/New_York")
- Library: Verify `date-fns` v4.1.0 timezone support first (may use `format` with `timeZone` option), OR install `date-fns-tz` if needed
- Calculate: "What time is 8 AM in user's timezone right now?"
- Query: Users where current time in their timezone is 8 AM ± 1 hour window

**Digest Email Content:**

- Group notifications by project
- Show count of each notification type
- List recent notifications (up to 10 per project)
- Include direct links to each project
- Summary line: "You have X notifications from Y projects"

**Processing Logic:**

```typescript
async function processDailyDigests() {
  // Query users with daily digest enabled
  const users = await db.query.notificationPreferences.findMany({
    where: eq(notificationPreferences.emailDigestFrequency, "daily"),
  })

  for (const pref of users) {
    // Check if it's 8 AM in user's timezone
    const userTime = getCurrentTimeInTimezone(pref.timezone)
    if (userTime.getHours() !== 8) continue

    // Get unprocessed notifications from last 24 hours
    const notifications = await getUnprocessedNotifications(pref.userId, "daily")

    if (notifications.length === 0) continue

    // Group by project
    const grouped = groupNotificationsByProject(notifications)

    // Send digest email
    await emailService.sendDailyDigestEmail({
      userId: pref.userId,
      notifications: grouped,
      date: new Date(),
    })

    // Mark as processed
    await markNotificationsAsProcessed(notifications.map((n) => n.id))
  }
}
```

### Project Structure

[Source: [docs/architecture/unified-project-structure.md](docs/architecture/unified-project-structure.md)]

**File Locations:**

```
apps/web/
├── src/
│   ├── server/
│   │   ├── db/schema/
│   │   │   ├── notification_preferences.ts    # New preferences schema
│   │   │   ├── email_logs.ts                  # New email log schema
│   │   │   └── digest_queue.ts                # New digest queue schema
│   │   ├── api/routers/
│   │   │   ├── notification_preferences.ts    # New preferences router
│   │   │   └── __tests__/
│   │   │       └── notification_preferences.test.ts
│   │   ├── services/
│   │   │   └── notifications.ts               # Modify: Add email integration
│   │   ├── utils/
│   │   │   ├── email-rate-limiter.ts          # New rate limiter
│   │   │   └── __tests__/
│   │   │       └── email-rate-limiter.test.ts
│   ├── lib/
│   │   └── email.ts                           # Modify: Add new email templates
│   ├── app/
│   │   ├── settings/
│   │   │   └── notifications/
│   │   │       ├── page.tsx                   # New settings page
│   │   │       └── __tests__/
│   │   │           └── page.test.tsx
│   │   └── unsubscribe/
│   │       └── [token]/
│   │           └── page.tsx                   # New unsubscribe page
├── scripts/
│   └── process-digests.ts                     # New cron job script
```

### API Patterns

[Source: [docs/architecture/coding-standards.md](docs/architecture/coding-standards.md)]

**tRPC Procedure Pattern:**

```typescript
import { createTRPCRouter, protectedProcedure } from "../trpc"
import { z } from "zod"

export const notificationPreferencesRouter = createTRPCRouter({
  getPreferences: protectedProcedure.query(async ({ ctx }) => {
    const userId = ctx.session.user.id

    // Query preferences
    let preferences = await ctx.db.query.notificationPreferences.findFirst({
      where: eq(notificationPreferences.userId, userId),
    })

    // Create defaults if not exist
    if (!preferences) {
      preferences = await ctx.db
        .insert(notificationPreferences)
        .values({
          userId,
          emailOnCost: true,
          emailOnLargeExpense: true,
          emailOnDocument: true,
          emailOnTimeline: true,
          emailOnComment: true,
          emailDigestFrequency: "immediate",
          timezone: "Australia/Sydney",
        })
        .returning()
        .then((rows) => rows[0])
    }

    return preferences
  }),

  updatePreferences: protectedProcedure
    .input(
      z.object({
        emailOnCost: z.boolean().optional(),
        emailOnLargeExpense: z.boolean().optional(),
        emailOnDocument: z.boolean().optional(),
        emailOnTimeline: z.boolean().optional(),
        emailOnComment: z.boolean().optional(),
        emailDigestFrequency: z.enum(["immediate", "daily", "weekly", "never"]).optional(),
        timezone: z.string().optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.session.user.id

      // Upsert pattern (insert or update)
      const updated = await ctx.db
        .insert(notificationPreferences)
        .values({
          userId,
          ...input,
          updatedAt: new Date(),
        })
        .onConflictDoUpdate({
          target: notificationPreferences.userId,
          set: {
            ...input,
            updatedAt: new Date(),
          },
        })
        .returning()

      return updated[0]
    }),
})
```

### UI Component Patterns

[Source: [docs/architecture/coding-standards.md](docs/architecture/coding-standards.md)]

**Settings Page Pattern:**

```typescript
'use client'

import { useState } from 'react'
import { Switch } from '@/components/ui/switch'
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group'
import { Select, SelectTrigger, SelectContent, SelectItem } from '@/components/ui/select'
import { Button } from '@/components/ui/button'
import { Label } from '@/components/ui/label'
import { api } from '@/lib/trpc/client'
import { toast } from 'sonner'

export default function NotificationSettingsPage() {
  const { data: preferences, isLoading } = api.notificationPreferences.getPreferences.useQuery()

  const updatePreferences = api.notificationPreferences.updatePreferences.useMutation({
    onSuccess: () => {
      toast.success('Notification preferences saved')
    },
    onError: (error) => {
      toast.error('Failed to save preferences: ' + error.message)
    },
  })

  const handleToggle = async (field: string, value: boolean) => {
    // Optimistic update
    await updatePreferences.mutateAsync({ [field]: value })
  }

  if (isLoading) return <div>Loading...</div>

  return (
    <div className="max-w-2xl mx-auto p-6">
      <h1 className="text-2xl font-bold mb-2">Notification Settings</h1>
      <p className="text-muted-foreground mb-6">
        Manage how you receive notifications about project activities
      </p>

      {/* Email Notification Types */}
      <section className="space-y-4 mb-8">
        <h2 className="text-lg font-semibold">Email Notifications</h2>

        <div className="flex items-center justify-between">
          <div>
            <Label htmlFor="emailOnCost">Cost Added</Label>
            <p className="text-sm text-muted-foreground">
              Receive emails when costs are added to projects
            </p>
          </div>
          <Switch
            id="emailOnCost"
            checked={preferences?.emailOnCost}
            onCheckedChange={(value) => handleToggle('emailOnCost', value)}
          />
        </div>

        {/* Additional toggles for other notification types */}
      </section>

      {/* Digest Frequency */}
      <section className="space-y-4 mb-8">
        <h2 className="text-lg font-semibold">Email Frequency</h2>

        <RadioGroup
          value={preferences?.emailDigestFrequency}
          onValueChange={(value) => updatePreferences.mutateAsync({ emailDigestFrequency: value })}
        >
          <div className="flex items-center space-x-2">
            <RadioGroupItem value="immediate" id="immediate" />
            <Label htmlFor="immediate">
              <div>Immediate</div>
              <div className="text-sm text-muted-foreground">
                Send emails as events happen
              </div>
            </Label>
          </div>

          {/* Additional radio options */}
        </RadioGroup>
      </section>

      {/* Timezone Selection */}
      <section className="space-y-4">
        <h2 className="text-lg font-semibold">Timezone</h2>

        <Select
          value={preferences?.timezone}
          onValueChange={(value) => updatePreferences.mutateAsync({ timezone: value })}
        >
          <SelectTrigger>
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="Australia/Sydney">Sydney (AEDT)</SelectItem>
            <SelectItem value="Australia/Melbourne">Melbourne (AEDT)</SelectItem>
            {/* Additional timezones */}
          </SelectContent>
        </Select>
      </section>
    </div>
  )
}
```

### Testing Strategy

[Source: [docs/architecture/testing-strategy.md](docs/architecture/testing-strategy.md)]

**Test Coverage Requirements:**

**Backend Unit Tests:**

- Notification preferences router (getPreferences, updatePreferences)
- Email rate limiter (10/hour limit, reset logic)
- Email template generation (all 7 types)
- Digest queue logic (queueForDigest, processDigests)
- Email log creation and retry logic

**Component Tests:**

- NotificationSettingsPage (toggles, radio buttons, select, save)
- UnsubscribePage (token validation, confirmation, success)

**Integration Tests:**

- Cost creation → check preferences → send email OR queue
- Update preferences → immediate save → verify database
- Unsubscribe → preferences updated → verify database
- Process digests → send emails → mark as processed

**E2E Tests:**

- Full settings flow (navigate to settings, update preferences, save, verify)
- Unsubscribe flow (receive email, click unsubscribe link, confirm, verify)

**Email Testing:**

- Use Resend's test mode for development
- Test all templates across email clients:
  - Gmail (web and mobile)
  - Outlook (web and desktop)
  - Apple Mail (macOS and iOS)
- Verify responsive design at different screen widths
- Verify all links work (entity links, unsubscribe links)

## Testing

### Test Location

[Source: [docs/architecture/testing-strategy.md](docs/architecture/testing-strategy.md)]

**Backend Tests:**

- Router tests: `apps/web/src/server/api/routers/__tests__/notification_preferences.test.ts`
- Service tests: `apps/web/src/server/services/__tests__/notifications.test.ts`
- Utility tests: `apps/web/src/server/utils/__tests__/email-rate-limiter.test.ts`

**Component Tests:**

- Settings page: `apps/web/src/app/settings/notifications/__tests__/page.test.tsx`
- Unsubscribe page: `apps/web/src/app/unsubscribe/[token]/__tests__/page.test.tsx`

**E2E Tests:**

- Settings flow: `apps/web/e2e/tests/notification-settings.spec.ts`

### Test Standards

**Framework:** Vitest ^1.6.0 for unit/integration tests, Playwright ^1.40.0 for E2E

**Testing Pattern:**

```typescript
import { describe, it, expect, vi } from "vitest"
import { appRouter } from "../root"
import { createTestContext } from "@/test/test-db"

describe("notificationPreferences.getPreferences", () => {
  it("creates default preferences if none exist", async () => {
    const ctx = await createTestContext()
    const caller = appRouter.createCaller(ctx)

    const preferences = await caller.notificationPreferences.getPreferences()

    expect(preferences).toMatchObject({
      userId: ctx.user.id,
      emailOnCost: true,
      emailOnLargeExpense: true,
      emailDigestFrequency: "immediate",
    })
  })

  it("returns existing preferences", async () => {
    const ctx = await createTestContext()
    const caller = appRouter.createCaller(ctx)

    // Create preferences first
    await ctx.db.insert(notificationPreferences).values({
      userId: ctx.user.id,
      emailOnCost: false,
      emailDigestFrequency: "daily",
    })

    const preferences = await caller.notificationPreferences.getPreferences()

    expect(preferences.emailOnCost).toBe(false)
    expect(preferences.emailDigestFrequency).toBe("daily")
  })
})
```

### Specific Testing Requirements

1. **Rate Limiting Tests:**
   - Test 10 emails sent successfully
   - Test 11th email blocked
   - Test counter resets after 1 hour
   - Test large expense emails bypass limit

2. **Email Template Tests:**
   - Test all 7 email types generate valid HTML
   - Test all emails include unsubscribe link
   - Test all emails include direct entity links
   - Test plain text versions match HTML content

3. **Digest Processing Tests:**
   - Test daily digest queues notifications
   - Test weekly digest queues notifications
   - Test processDigests sends emails at correct times
   - Test timezone handling (8 AM in user's timezone)
   - Test notifications marked as processed after sending

4. **Preference Update Tests:**
   - Test optimistic updates (immediate UI response)
   - Test rollback on error
   - Test RBAC (user can only update own preferences)
   - Test upsert pattern (insert if not exist, update if exist)

## Change Log

| Date       | Version | Description                                                                                                                                                                                                                                                           | Author     |
| ---------- | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| 2025-11-03 | 1.0     | Initial story creation                                                                                                                                                                                                                                                | Bob        |
| 2025-11-03 | 1.1     | PO validation updates: Added timezone library verification subtask (date-fns v4.1.0 check), specified JWT implementation details (better-auth utilities, 90-day expiry, BETTER_AUTH_SECRET), clarified cron scheduling approach (Netlify scheduled functions primary) | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

<!-- To be filled by Dev Agent -->

### Debug Log References

<!-- To be filled by Dev Agent -->

### Completion Notes List

<!-- To be filled by Dev Agent -->

### File List

<!-- To be filled by Dev Agent -->

## QA Results

<!-- To be filled by QA Agent -->
