# Story 6.1: Implement Two-Factor Authentication (2FA)

## Status

Approved

## Story

**As a** registered user,
**I want** to enable two-factor authentication on my account,
**so that** my account is protected with an additional layer of security beyond just my password.

## Acceptance Criteria

1. User can enable 2FA from account settings
2. QR code generated for authenticator app setup
3. Backup codes generated (10 codes) and displayed once
4. Login flow prompts for 2FA code when enabled
5. Backup codes work for authentication
6. User can disable 2FA (requires current password + 2FA code)
7. User can regenerate backup codes
8. "Remember this device" option works for 30 days
9. 2FA status visible on account settings
10. Users without 2FA can login normally (no disruption)

## Tasks / Subtasks

- [ ] Extend database schema for 2FA support (AC: 1, 2, 3, 5)
  - [ ] Add 2FA columns to users table:
    - [ ] `twoFactorEnabled` (boolean, default false)
    - [ ] `twoFactorSecret` (text, encrypted storage for TOTP secret)
    - [ ] `backupCodes` (jsonb, array of hashed codes)
  - [ ] Create `trusted_devices` table:
    - [ ] `id` (UUID primary key)
    - [ ] `userId` (text, FK to users.id)
    - [ ] `deviceFingerprint` (text, unique device identifier)
    - [ ] `deviceName` (text, user-friendly device name)
    - [ ] `lastUsedAt` (timestamp)
    - [ ] `expiresAt` (timestamp, 30 days from creation)
    - [ ] `createdAt` (timestamp)
  - [ ] Run database migration:
    - [ ] Generate migration: `bunx drizzle-kit generate`
    - [ ] Review migration file in `drizzle/migrations/`
    - [ ] Apply migration: `bunx drizzle-kit push`
    - [ ] Verify schema in database

- [ ] Create UI components (AC: 1, 4, 9)
  - [ ] `TwoFactorSetupDialog` component (QR code + verification)
  - [ ] `TwoFactorVerifyForm` component (6-digit code input)
  - [ ] `BackupCodesDisplay` component (display + download)
  - [ ] `TrustedDevicesList` component (list devices + revoke)
  - [ ] `SecuritySettingsSection` component (2FA status + controls)
  - [ ] Follow Shadcn/ui patterns for all components
  - [ ] Ensure mobile responsiveness (touch-friendly inputs)

- [ ] Implement 2FA setup flow in account settings (AC: 1, 2, 3)
  - [ ] Create `/settings/security` page component
  - [ ] Add "Enable 2FA" section with current status indicator
  - [ ] Generate TOTP secret using better-auth or `otpauth` library
  - [ ] Generate QR code using `qrcode` npm package
  - [ ] Display QR code + manual entry key for authenticator apps
  - [ ] Create verification step: user enters 6-digit code to confirm setup
  - [ ] Generate 10 backup codes (random alphanumeric, 8 characters each)
  - [ ] Hash backup codes before storing (use bcrypt)
  - [ ] Display backup codes once with download/copy options
  - [ ] Show confirmation modal: "Save these codes securely"
  - [ ] Update `users.twoFactorEnabled = true` on successful verification

- [ ] Implement 2FA login challenge (AC: 4, 5, 8)
  - [ ] Modify login flow to detect if user has 2FA enabled
  - [ ] After successful email/password validation, redirect to 2FA challenge page
  - [ ] Create `/login/verify-2fa` page with code input
  - [ ] Validate 6-digit TOTP code against user's secret
  - [ ] Accept backup codes as alternative authentication
  - [ ] Mark used backup codes as consumed (remove from array)
  - [ ] Add "Remember this device for 30 days" checkbox
  - [ ] If checked, create `trusted_devices` entry with:
    - [ ] Device fingerprint (User-Agent + IP hash)
    - [ ] Expiry timestamp (30 days from now)
  - [ ] Skip 2FA challenge if trusted device exists and not expired
  - [ ] Allow max 3 failed attempts before rate limiting (5 minute cooldown)

- [ ] Implement 2FA management features (AC: 6, 7, 9)
  - [ ] Create "Disable 2FA" button in security settings
  - [ ] Require current password + valid 2FA code to disable
  - [ ] Clear `twoFactorSecret` and `twoFactorEnabled` on disable
  - [ ] Delete all trusted devices when 2FA disabled
  - [ ] Create "Regenerate Backup Codes" button
  - [ ] Require valid 2FA code to regenerate codes
  - [ ] Generate new set of 10 backup codes, replace old ones
  - [ ] Display 2FA status prominently in settings:
    - [ ] "2FA Enabled ✓" or "2FA Disabled ⚠️"
    - [ ] Show number of remaining backup codes
    - [ ] Show list of trusted devices with "Revoke" option

- [ ] Ensure backward compatibility (AC: 10)
  - [ ] Verify existing login flow works for users without 2FA
  - [ ] No changes to authentication for non-2FA users
  - [ ] 2FA challenge only triggers if `twoFactorEnabled = true`
  - [ ] Test login with existing user accounts (no migration required)

- [ ] Write tests for 2FA functionality
  - [ ] Unit test: TOTP secret generation and validation
  - [ ] Unit test: Backup code generation and hashing
  - [ ] Integration test: Complete 2FA setup flow
  - [ ] Integration test: Login with 2FA enabled
  - [ ] Integration test: Login with backup code
  - [ ] Integration test: Trusted device creation and validation
  - [ ] Integration test: 2FA disable flow
  - [ ] E2E test: Full user journey (setup → login → disable)

## Dev Notes

### Existing System Context

**Authentication Implementation:**
[Source: [apps/web/src/server/auth.ts](apps/web/src/server/auth.ts)]

- Better-auth v1.3.13 configured with Drizzle adapter
- Email/password authentication enabled
- Session expires in 30 days, updates every 24 hours
- Rate limiting: 10 requests per minute for auth endpoints
- Users table: `id`, `email`, `name`, `firstName`, `lastName`, `role`, `emailVerified`

**Database:**

- Neon PostgreSQL (serverless)
- Drizzle ORM for migrations and queries
- Users schema: [apps/web/src/server/db/schema/users.ts](apps/web/src/server/db/schema/users.ts)

**Tech Stack:**
[Source: [docs/architecture/tech-stack.md](docs/architecture/tech-stack.md)]

- Next.js 14 with App Router
- TypeScript 5.3
- tRPC for API layer
- Zod for validation
- Shadcn/ui components + Tailwind CSS

### File Locations

**Components:** (create in `apps/web/src/components/auth/`)

- `TwoFactorSetupDialog.tsx` - Dialog for 2FA setup with QR code
- `TwoFactorVerifyForm.tsx` - Form for 6-digit code input during login
- `BackupCodesDisplay.tsx` - Display and download backup codes
- `TrustedDevicesList.tsx` - List of trusted devices with revoke option
- `SecuritySettingsSection.tsx` - 2FA status and controls for settings page

**Pages:** (Next.js App Router structure)

- Security settings: `apps/web/src/app/settings/security/page.tsx`
- 2FA verification: `apps/web/src/app/login/verify-2fa/page.tsx`

**Database Schema:**

- Extend users table: `apps/web/src/server/db/schema/users.ts`
- New trusted_devices table: `apps/web/src/server/db/schema/trusted-devices.ts`

**tRPC Router:**

- Auth endpoints: `apps/web/src/server/api/routers/auth.ts` (extend existing router)

**Tests:**

- Backend tests: `apps/web/src/server/__tests__/auth/two-factor.test.ts`
- Component tests: Co-located with components in `apps/web/src/components/auth/__tests__/`

### Integration Points

**Better-Auth 2FA Integration:**

**Research Required:** Check better-auth v1.3.13 documentation for built-in 2FA/TOTP plugin support.

**If better-auth has 2FA plugin:**

- Use better-auth native 2FA plugin following their documentation
- Leverage built-in session integration
- May still need custom UI components

**If no better-auth 2FA plugin (manual implementation):**

- `otpauth` - TOTP secret generation and validation (RFC 6238)
- `qrcode` - QR code generation for authenticator apps
- `bcrypt` - Hashing backup codes before storage

**New Dependencies to Install:**

**If manual implementation is needed:**

```bash
# Install production dependencies
bun add otpauth qrcode bcrypt

# Install dev dependencies
bun add -D @types/qrcode
```

**Note:** These libraries are not currently in the tech stack and must be added to package.json.

**Session Management:**

- Extend better-auth session validation to check trusted devices
- Add middleware to verify 2FA completion before granting session
- Store trusted device token in secure httpOnly cookie

**Partial Session Handling During 2FA Challenge:**

After successful password validation but before 2FA verification:

1. **Create temporary session token** (not a full session)
   - Generate short-lived token (5-minute expiry)
   - Store in secure httpOnly cookie: `2fa_challenge_token`
   - Include user ID and timestamp in encrypted token

2. **On 2FA verification success:**
   - Validate temporary token exists and not expired
   - Exchange temporary token for full better-auth session
   - Clear `2fa_challenge_token` cookie
   - Create regular session with better-auth

3. **On timeout or failure:**
   - Clear temporary session token
   - Redirect back to login page
   - Show appropriate error message

4. **Security considerations:**
   - Temporary token is single-use only
   - Token cannot be used to access protected resources
   - Token only grants access to 2FA verification endpoint

**tRPC Endpoints to Create:**

- `auth.setup2FA` - Generate secret, return QR code data URL
- `auth.verify2FASetup` - Verify code, save secret, generate backup codes
- `auth.verify2FALogin` - Validate code during login
- `auth.disable2FA` - Disable 2FA (requires password + code)
- `auth.regenerateBackupCodes` - Create new backup codes
- `auth.getTrustedDevices` - List user's trusted devices
- `auth.revokeTrustedDevice` - Remove device from trusted list

### Technical Implementation Notes

**TOTP Implementation:**

```typescript
// Generate secret (32 character base32 string)
import { authenticator } from "otpauth"

const secret = authenticator.generateSecret()
const totp = new authenticator.TOTP({
  issuer: "Real Estate Tracker",
  label: user.email,
  algorithm: "SHA1",
  digits: 6,
  period: 30,
  secret: secret,
})

// Generate QR code
const qrCodeDataURL = await QRCode.toDataURL(totp.toString())
```

**Backup Code Generation:**

```typescript
// Generate 10 codes: "XXXX-XXXX" format
import crypto from "crypto"
import bcrypt from "bcrypt"

function generateBackupCodes(count = 10): string[] {
  return Array.from({ length: count }, () => {
    const code = crypto.randomBytes(4).toString("hex").toUpperCase()
    return `${code.slice(0, 4)}-${code.slice(4, 8)}`
  })
}

// Hash before storing
const hashedCodes = await Promise.all(codes.map((code) => bcrypt.hash(code, 10)))
```

**Device Fingerprinting:**

```typescript
// Create fingerprint from User-Agent + IP
import crypto from "crypto"

function createDeviceFingerprint(userAgent: string, ip: string): string {
  return crypto.createHash("sha256").update(`${userAgent}:${ip}`).digest("hex")
}
```

### Security Considerations

**OWASP Best Practices:**

- Hash backup codes before storage (never store plaintext)
- Rate limit 2FA verification attempts (max 3 failures, then 5 min cooldown)
- Use secure random number generation for secrets and codes
- Implement brute-force protection on login + 2FA endpoints
- Clear 2FA session state on logout
- Expire trusted devices after 30 days (automatic cleanup job)

**TOTP Secret Encryption:**

Choose one of the following approaches for encrypting TOTP secrets at rest:

**Option 1 (Recommended): Database-level encryption**

- Neon PostgreSQL supports column-level encryption
- No application code changes needed
- Managed by database platform
- Transparent to application layer

**Option 2: Application-level encryption**

- Use Node.js `crypto` module with AES-256-GCM
- Store encryption key in environment variable (`TOTP_ENCRYPTION_KEY`)
- Encrypt before saving to database, decrypt when validating codes
- Example implementation:

```typescript
import crypto from "crypto"

const ALGORITHM = "aes-256-gcm"
const KEY = Buffer.from(process.env.TOTP_ENCRYPTION_KEY!, "hex") // 32 bytes

function encrypt(text: string): string {
  const iv = crypto.randomBytes(16)
  const cipher = crypto.createCipheriv(ALGORITHM, KEY, iv)
  const encrypted = Buffer.concat([cipher.update(text, "utf8"), cipher.final()])
  const authTag = cipher.getAuthTag()
  return `${iv.toString("hex")}:${authTag.toString("hex")}:${encrypted.toString("hex")}`
}

function decrypt(encryptedData: string): string {
  const [ivHex, authTagHex, encryptedHex] = encryptedData.split(":")
  const iv = Buffer.from(ivHex, "hex")
  const authTag = Buffer.from(authTagHex, "hex")
  const encrypted = Buffer.from(encryptedHex, "hex")
  const decipher = crypto.createDecipheriv(ALGORITHM, KEY, iv)
  decipher.setAuthTag(authTag)
  return decipher.update(encrypted) + decipher.final("utf8")
}
```

**User Experience:**

- Provide clear setup instructions with screenshots
- Support multiple authenticator apps (Google, Authy, Microsoft, 1Password)
- Allow download of backup codes as .txt file
- Show clear error messages for invalid codes
- Provide "Lost access?" recovery flow documentation

### Existing Patterns to Follow

**Form Components:**
[Source: [docs/architecture/coding-standards.md](docs/architecture/coding-standards.md)]

- Use React Hook Form + Zod validation
- Shadcn/ui Form components for consistency
- Server-side validation on all mutations
- Display inline errors with FormMessage

**Error Handling:**

- Use TRPCError with appropriate codes
- `UNAUTHORIZED` for invalid 2FA codes
- `FORBIDDEN` for disabled 2FA operations
- `TOO_MANY_REQUESTS` for rate limit exceeded

**Database Patterns:**

- Use Drizzle ORM transactions for multi-step operations
- Soft delete pattern (deletedAt column)
- UUID primary keys for security
- Server-side Zod validation required

### Risk Mitigation

**Primary Risk:** Users locked out if they lose 2FA device and backup codes

**Mitigation Strategies:**

1. Backup codes prominently displayed during setup
2. Option to download backup codes as file
3. Clear documentation on recovery process
4. Admin ability to disable 2FA via direct database access (emergency only)
5. Email notification when 2FA is enabled/disabled

**Rollback Plan:**

- Feature flag: Can disable 2FA feature entirely
- Per-user disable: Admin can set `twoFactorEnabled = false` via database
- Database changes are additive (new columns, new table) - no data loss on rollback

### Testing

**Test Environment:**

- Location: `apps/web/src/server/__tests__/auth/two-factor.test.ts`
- Use Vitest for unit and integration tests
- Create test fixtures for users with 2FA enabled/disabled
- Mock TOTP verification for deterministic tests

**Test Coverage Required:**

1. TOTP secret generation is unique and valid
2. QR code data URL is properly formatted
3. Backup codes are random and properly hashed
4. Valid TOTP code passes verification
5. Invalid code fails verification
6. Backup code can be used once and then consumed
7. Trusted device bypasses 2FA challenge
8. Expired trusted device requires 2FA verification
9. Rate limiting triggers after 3 failed attempts
10. Disable 2FA clears all related data
11. Users without 2FA login normally (regression test)

**Testing Frameworks:**
[Source: [docs/architecture/tech-stack.md](docs/architecture/tech-stack.md)]

- Vitest for backend unit/integration tests
- Testing Library for component tests
- Playwright for E2E user flows

## Change Log

| Date       | Version | Description                                                                                                                               | Author |
| ---------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------------- | ------ |
| 2025-10-31 | 1.0     | Initial story creation from Epic 6                                                                                                        | Sarah  |
| 2025-10-31 | 1.1     | Validation fixes applied: task reordering, file paths, better-auth clarification, encryption details, dependencies list, session handling | Sarah  |

## Dev Agent Record

### Agent Model Used

(To be populated by dev agent)

### Debug Log References

(To be populated by dev agent)

### Completion Notes List

(To be populated by dev agent)

### File List

(To be populated by dev agent)

## QA Results

(To be populated by QA agent)
