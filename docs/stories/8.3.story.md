# Story 8.3: Threaded Comments on Entities

## Status

Ready for Review

## Story

**As a** project owner or partner,
**I want** to add comments and replies to costs, documents, and timeline events,
**so that** I can collaborate with team members, ask questions, and provide context directly on project entities without needing external communication.

## Acceptance Criteria

1. [x] Comments table created with proper schema and indexes
2. [x] Comment thread component displays below costs, documents, events
3. [x] Comments sorted chronologically (oldest first)
4. [x] New comment form visible at bottom of thread
5. [x] Comment submission creates comment and clears form
6. [x] Comment form has character counter (2000 max)
7. [x] User avatar, name, and timestamp display on each comment
8. [x] "Reply" button shows inline reply form with cancel option
9. [x] Nested replies indented and visually connected to parent
10. [x] One-level nesting enforced (no nested reply buttons on replies)
11. [x] Edit button works for own comments (inline edit form)
12. [x] Delete button works for own comments and project owner
13. [x] Deleted comments show "[Comment deleted]" placeholder
14. [x] "Edited" indicator shows if comment was modified
15. [x] Notifications generated for new comments
16. [x] Comment count badge shows on entity cards
17. [x] @mention autocomplete searches project members
18. [x] Mentioned users receive notifications
19. [x] Markdown rendering works (bold, italic, links)
20. [x] XSS protection implemented (sanitize HTML)
21. [x] Comments respect RBAC (only project members can comment)
22. [x] Real-time updates work (new comments appear within 30s)
23. [x] Empty state shows "No comments yet" with prompt

## Tasks / Subtasks

- [x] Create comments database schema (AC: 1)
  - [x] Create Drizzle schema file: `apps/web/src/server/db/schema/comments.ts`
  - [x] Define `comments` table with fields:
    - [x] `id` (uuid, primary key)
    - [x] `userId` (text, foreign key to users.id, CASCADE on delete)
    - [x] `entityType` (text, enum: 'cost', 'document', 'event')
    - [x] `entityId` (text, non-null, indexed for entity lookups)
    - [x] `projectId` (text, foreign key to projects.id, CASCADE on delete)
    - [x] `content` (text, max 2000 characters)
    - [x] `parentCommentId` (text, nullable, foreign key to comments.id, SET NULL on delete)
    - [x] `createdAt` (timestamp, default now())
    - [x] `updatedAt` (timestamp, default now(), updated on edit)
    - [x] `deletedAt` (timestamp, nullable, for soft delete)
  - [x] Create indexes:
    - [x] Composite index on (entityType, entityId) for fast entity comment lookups
    - [x] Index on userId for user comment queries
    - [x] Index on projectId for project-scoped queries
    - [x] Index on parentCommentId for reply queries
  - [x] Generate migration file: `bunx drizzle-kit generate`
  - [x] Apply migration to production: `NETLIFY_DATABASE_URL="..." bunx drizzle-kit push`
  - [x] Export schema from `apps/web/src/server/db/schema/index.ts`

- [x] Create tRPC comments router (AC: 2, 4, 5, 11, 12, 21)
  - [x] Create router file: `apps/web/src/server/api/routers/comments.ts`
  - [x] Implement `list` query:
    - [x] Input: `{ entityType: string, entityId: string }` (Zod validation)
    - [x] Verify authentication (protected procedure)
    - [x] Query comments for entity where deletedAt IS NULL
    - [x] Include user name/avatar via join
    - [x] Sort by createdAt ASC (oldest first)
    - [x] Group replies under parent comments
    - [x] Return: Comment[] with nested replies
  - [x] Implement `create` mutation:
    - [x] Input: `{ entityType, entityId, projectId, content, parentCommentId? }` (Zod validation)
    - [x] Verify authentication and project access (RBAC check)
    - [x] Validate content length â‰¤ 2000 characters
    - [x] If parentCommentId provided:
      - [x] Verify parent exists and is not deleted
      - [x] Verify parent is not itself a reply (enforce one-level nesting only)
      - [x] Throw TRPCError BAD_REQUEST if parent has parentCommentId: "Cannot reply to a reply - only one level nesting allowed"
    - [x] Create comment in database
    - [x] Trigger notification generation (entity owner, thread participants, @mentions)
    - [x] Return: created Comment
  - [x] Implement `update` mutation:
    - [x] Input: `{ commentId: string, content: string }` (Zod validation)
    - [x] Verify authentication
    - [x] Verify user owns comment (userId === ctx.user.id)
    - [x] Update comment content and updatedAt timestamp
    - [x] Return: updated Comment
  - [x] Implement `delete` mutation:
    - [x] Input: `{ commentId: string }` (Zod validation)
    - [x] Verify authentication
    - [x] Verify user owns comment OR user is project owner
    - [x] Soft delete: Set deletedAt = NOW()
    - [x] Return: success boolean
  - [x] Implement `getCount` query:
    - [x] Input: `{ entityType: string, entityId: string }` (Zod validation)
    - [x] Count comments where deletedAt IS NULL
    - [x] Return: number
  - [x] Add router to root router in `apps/web/src/server/api/root.ts`

- [x] Create CommentThread UI component (AC: 2, 3, 4, 7, 8, 9, 10, 13, 23)
  - [x] Create component file: `apps/web/src/components/comments/CommentThread.tsx`
  - [x] Component props:
    - [x] `entityType: 'cost' | 'document' | 'event'`
    - [x] `entityId: string`
    - [x] `projectId: string`
  - [x] Use tRPC `comments.list` query to fetch comments
  - [x] Implement loading state (skeleton components)
  - [x] Implement empty state: "No comments yet. Be the first to comment!"
  - [x] Map comments to CommentItem components
  - [x] Sort comments by createdAt (oldest first) - server already does this
  - [x] Render top-level comments first, then nested replies
  - [x] Add NewCommentForm at bottom of thread
  - [x] Implement real-time updates: React Query refetch interval 30s (AC #22)

- [x] Create CommentItem component (AC: 7, 8, 9, 10, 11, 12, 13, 14)
  - [x] Create component file: `apps/web/src/components/comments/CommentItem.tsx`
  - [x] Component props:
    - [x] `comment: Comment`
    - [x] `currentUserId: string`
    - [x] `projectOwnerId: string`
    - [x] `isReply: boolean` (for styling indentation)
    - [x] `onReplySubmit: (content: string, parentId: string) => void`
    - [x] `onEdit: (commentId: string, content: string) => void`
    - [x] `onDelete: (commentId: string) => void`
  - [x] Display user avatar (Shadcn/ui Avatar component)
  - [x] Display user name and timestamp (format with date-fns)
  - [x] Display comment content with markdown rendering (react-markdown)
  - [x] Show "Edited" indicator if updatedAt > createdAt + 1 minute
  - [x] Show deleted placeholder if deletedAt is set: "[Comment deleted]"
  - [x] Show "Reply" button (only if not a reply - one-level nesting)
  - [x] Show "Edit" and "Delete" buttons if user owns comment
  - [x] Project owner can see "Delete" button on any comment
  - [x] Implement inline reply form (toggle visibility on "Reply" click)
  - [x] Implement inline edit form (toggle visibility on "Edit" click)
  - [x] On successful edit/delete, invalidate `comments.list` query for real-time updates
  - [x] Apply indentation styling for replies (ml-8 border-l-2)

- [x] Create NewCommentForm component (AC: 4, 5, 6)
  - [x] Create component file: `apps/web/src/components/comments/NewCommentForm.tsx`
  - [x] Component props:
    - [x] `entityType: string`
    - [x] `entityId: string`
    - [x] `projectId: string`
    - [x] `parentCommentId?: string` (for replies)
    - [x] `onSuccess: () => void`
    - [x] `onCancel?: () => void` (for inline reply forms)
    - [x] `placeholder?: string`
  - [x] Use React Hook Form with Zod validation
  - [x] Textarea input (Shadcn/ui Textarea component)
  - [x] Character counter: "X / 2000 characters"
  - [x] Disable submit if content is empty or > 2000 characters
  - [x] Submit button: "Comment" or "Reply" based on context
  - [x] Cancel button (only for inline reply/edit forms)
  - [x] On submit: call `comments.create` mutation
  - [x] Clear form after successful submission
  - [x] Invalidate queries on success for real-time updates:
    - [x] Invalidate `comments.list` query for current entity
    - [x] Invalidate `comments.getCount` query for current entity (updates badge)
  - [x] Show error toast on failure (Shadcn/ui toast)
  - [x] Implement @mention autocomplete (AC #17):
    - [x] Detect "@" character in textarea
    - [x] Query project members via tRPC
    - [x] Show autocomplete dropdown with user names
    - [x] Insert "@username" on selection
    - [x] Use `react-mentions` or custom implementation

- [x] Add markdown rendering support (AC: 19)
  - [x] Install `react-markdown` library: `bun add react-markdown`
  - [x] Install `remark-gfm` for GitHub-flavored markdown: `bun add remark-gfm`
  - [x] Configure markdown renderer in CommentItem:
    - [x] Allowed elements: strong, em, a, p, br
    - [x] Disallow: img, script, iframe, html tags
    - [x] Sanitize links to prevent javascript: URLs
  - [x] Install `dompurify` for XSS protection: `bun add dompurify`
  - [x] Sanitize HTML output in CommentItem (AC #20)

- [x] Add comment notifications (AC: 15, 18)
  - [x] Update `apps/web/src/server/services/notifications.ts`:
    - [x] Add `notifyCommentAdded` function
    - [x] Collect notification recipients:
      - [x] Entity owner (cost/document/event creator)
      - [x] All previous commenters in thread (distinct user IDs)
      - [x] Parse content for @mentions (regex: /@(\w+)/g)
      - [x] Query users by username from @mentions
      - [x] Mentioned users
    - [x] Deduplicate all recipients (entity owner + thread participants + @mentions) by user ID
    - [x] Exclude comment author from notifications (no self-notification)
    - [x] Send one notification per unique user ID
    - [x] Use NotificationType.COMMENT_ADDED
    - [x] Message template: "{userName} commented on {entityType} in {projectName}"
  - [x] Call `notifyCommentAdded` from `comments.create` mutation
  - [x] Implement email notifications (Story 8.2 integration):
    - [x] Create email template for comment notifications using Resend
    - [x] Template structure:
      - [x] Subject: "{commenterName} commented on {entityType} in {projectName}"
      - [x] Body includes: Commenter name and avatar
      - [x] Body includes: Comment content (first 200 characters with "..." if truncated)
      - [x] Body includes: Entity name/description
      - [x] Body includes: Project name
      - [x] Body includes: Direct link to entity with comment thread (deep link)
      - [x] Body includes: Unsubscribe link (managed via Story 8.2 preferences)
    - [x] Respect user email preferences (emailOnComment toggle)
    - [x] Fire-and-forget pattern (don't block comment creation on email failure)

- [x] Add comment count badges (AC: 16)
  - [x] Update cost card component: `apps/web/src/components/costs/CostCard.tsx`
    - [x] Add tRPC `comments.getCount` query
    - [x] Display comment count badge (Shadcn/ui Badge)
    - [x] Format: "ðŸ’¬ {count}" if count > 0
  - [x] Update document card component: `apps/web/src/components/documents/DocumentCard.tsx`
    - [x] Same implementation as cost card
  - [x] Update timeline event card: `apps/web/src/components/events/EventCard.tsx`
    - [x] Same implementation as cost card

- [x] Integrate CommentThread into entity pages
  - [x] Cost detail page: `apps/web/src/app/projects/[projectId]/costs/[costId]/page.tsx`
    - [x] Add CommentThread component below cost details
    - [x] Pass entityType="cost", entityId=costId, projectId
  - [x] Document detail page: `apps/web/src/app/projects/[projectId]/documents/[documentId]/page.tsx`
    - [x] Add CommentThread component below document preview
    - [x] Pass entityType="document", entityId=documentId, projectId
  - [x] Timeline event detail page: `apps/web/src/app/projects/[projectId]/events/[eventId]/page.tsx`
    - [x] Add CommentThread component below event details
    - [x] Pass entityType="event", entityId=eventId, projectId

- [x] Write comprehensive tests (AC: 1-23)
  - [x] Backend router tests: `apps/web/src/server/api/routers/__tests__/comments.test.ts`
    - [x] Test `list` query (returns comments for entity, excludes deleted)
    - [x] Test `create` mutation (creates comment, triggers notifications)
    - [x] Test `create` with parent (creates reply, enforces one-level nesting)
    - [x] Test `update` mutation (updates own comment, rejects others')
    - [x] Test `delete` mutation (soft deletes own comment, project owner can delete any)
    - [x] Test `getCount` query (counts non-deleted comments)
    - [x] Test RBAC (user must be project member to comment)
    - [x] Test character limit validation (2000 max)
  - [x] Component tests:
    - [x] CommentThread.test.tsx (renders comments, loading/empty states, real-time updates)
    - [x] CommentItem.test.tsx (displays comment, reply/edit/delete buttons, markdown rendering)
    - [x] NewCommentForm.test.tsx (submits comment, validates length, clears form)
  - [x] Integration tests:
    - [x] Create comment â†’ notification sent to entity owner
    - [x] Reply to comment â†’ notification sent to parent commenter
    - [x] @mention â†’ notification sent to mentioned user
    - [x] Edit comment â†’ updatedAt timestamp updated
    - [x] Delete comment â†’ soft delete, shows placeholder
  - [x] E2E tests:
    - [x] Full comment thread flow (add comment, reply, edit, delete)
    - [x] @mention autocomplete flow
    - [x] Comment count badge updates

## Dev Notes

### Previous Story Insights

**From Story 8.1 (In-App Notifications - Complete):**

- Notification generation system working well via `notifications.ts` service
- `notifyProjectMembers()` function batches notifications to all project members
- `createNotification()` for single-user notifications
- NotificationType enum includes COMMENT_ADDED (ready to use)
- Real-time updates via React Query polling (30s interval) proven effective

**From Story 8.2 (Email Notifications - Complete):**

- Email template system in place using Resend
- User preferences system with `emailOnComment` toggle
- Fire-and-forget email pattern prevents transaction failures
- Email templates include project name, entity description, direct links
- Rate limiting (10 emails/hour) already implemented

**Key Takeaways:**

- Extend existing notification system to trigger on comment creation
- Follow established tRPC procedure patterns (protectedProcedure, Zod validation)
- Use Shadcn/ui components for consistency (Textarea, Avatar, Button, Badge)
- Implement RBAC at query level (verify project access before mutations)
- Use soft delete pattern for comments (deletedAt timestamp)
- Real-time updates via React Query refetchInterval (30s)

### Tech Stack

[Source: [docs/architecture/tech-stack.md](docs/architecture/tech-stack.md)]

**Core Technologies:**

- Frontend: Next.js ^14.2.0, TypeScript ^5.3.0, React Query ^5.0.0
- UI: Shadcn/ui ^0.8.0, Tailwind CSS ^3.4.0
- Backend: tRPC ^10.45.0, Drizzle ORM ^0.44.6
- Database: Neon PostgreSQL (serverless)
- Validation: Zod ^3.22.0 for runtime validation
- Testing: Vitest ^1.6.0, Testing Library ^14.0.0, Playwright ^1.40.0

**Additional Libraries Needed:**

- `react-markdown` ^9.0.0 - Markdown rendering for comment content
- `remark-gfm` ^4.0.0 - GitHub-flavored markdown support (bold, italic, links)
- `dompurify` ^3.0.0 - HTML sanitization for XSS protection
- `react-mentions` ^4.4.0 (optional) - @mention autocomplete functionality
- `date-fns` ^3.0.0 - Already installed, use for timestamp formatting

### Data Models

[Source: [docs/architecture/data-models.md](docs/architecture/data-models.md)]

**New Model: Comment**

```typescript
interface Comment extends BaseEntity {
  id: string // UUID
  userId: string // Foreign key to users.id (CASCADE)
  entityType: "cost" | "document" | "event"
  entityId: string // ID of the related entity
  projectId: string // Foreign key to projects.id (CASCADE)
  content: string // Max 2000 characters
  parentCommentId: string | null // Foreign key to comments.id (SET NULL)
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null // Soft delete
}
```

**Database Schema (Drizzle):**

```typescript
import { pgTable, text, timestamp, uuid, index } from "drizzle-orm/pg-core"
import { users } from "./users"
import { projects } from "./projects"

export const CommentEntityType = {
  COST: "cost",
  DOCUMENT: "document",
  EVENT: "event",
} as const

export type CommentEntityType = (typeof CommentEntityType)[keyof typeof CommentEntityType]

export const comments = pgTable(
  "comments",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    entityType: text("entity_type").notNull(), // One of CommentEntityType
    entityId: text("entity_id").notNull(),
    projectId: text("project_id")
      .notNull()
      .references(() => projects.id, { onDelete: "cascade" }),
    content: text("content").notNull(), // Max 2000 characters (enforce in Zod)
    parentCommentId: uuid("parent_comment_id").references(() => comments.id, {
      onDelete: "set null",
    }),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
    deletedAt: timestamp("deleted_at"),
  },
  (table) => ({
    // Composite index for entity comment lookups
    entityIdx: index("comments_entity_idx").on(table.entityType, table.entityId),
    // Index for user comment queries
    userIdIdx: index("comments_user_id_idx").on(table.userId),
    // Index for project-scoped queries
    projectIdIdx: index("comments_project_id_idx").on(table.projectId),
    // Index for reply queries
    parentIdIdx: index("comments_parent_id_idx").on(table.parentCommentId),
  })
)
```

**Relations:**

- Belongs to User (commenter)
- Belongs to Project
- Belongs to Comment (parent, optional)
- Has many Comments (replies)

### Existing Notification System

[Source: [apps/web/src/server/services/notifications.ts](apps/web/src/server/services/notifications.ts)]

**Notification Generation Functions:**

```typescript
// Create single notification
createNotification({
  userId: string,
  type: NotificationType,
  entityType: NotificationEntityType,
  entityId: string,
  projectId: string,
  message: string
}): Promise<void>

// Notify all project members (owner + partners)
notifyProjectMembers({
  projectId: string,
  excludeUserId?: string, // Avoid self-notification
  type: NotificationType,
  entityType: NotificationEntityType,
  entityId: string,
  messageData: Record<string, unknown>
}): Promise<void>
```

**NotificationType.COMMENT_ADDED:**

- Already defined in schema: `apps/web/src/server/db/schema/notifications.ts`
- Message template: `"{commenterName} commented on {entityType} in {projectName}"`
- Entity types: 'cost', 'document', 'event'

**Notification Integration Points:**

1. **New Comment:** Notify entity owner + previous thread participants (deduplicated)
2. **@Mentions:** Parse content for @username, notify mentioned users
3. **Email Integration:** Respect `emailOnComment` preference from Story 8.2

### Component Patterns

[Source: [docs/architecture/coding-standards.md](docs/architecture/coding-standards.md)]

**Form Pattern:**

```typescript
// Standard pattern: React Hook Form + Zod + Shadcn/ui
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"

const commentSchema = z.object({
  content: z.string().min(1, "Comment cannot be empty").max(2000, "Comment too long"),
})

const form = useForm<z.infer<typeof commentSchema>>({
  resolver: zodResolver(commentSchema),
})
```

**Loading States:**

```typescript
// Initial load: Show skeleton components
if (isLoading) {
  return <CommentListSkeleton count={3} />
}

// Empty state: Friendly message with clear CTA
if (comments.length === 0) {
  return (
    <EmptyState
      icon="ðŸ’¬"
      title="No comments yet"
      description="Be the first to comment on this item!"
    />
  )
}
```

**Optimistic Updates:**

```typescript
// Create comment: Add immediately, rollback on error
const createMutation = api.comments.create.useMutation({
  onMutate: async (newComment) => {
    await queryClient.cancelQueries(["comments", entityType, entityId])
    const previous = queryClient.getQueryData(["comments", entityType, entityId])

    // Optimistically add comment
    queryClient.setQueryData(["comments", entityType, entityId], (old) => [
      ...old,
      { ...newComment, id: "temp", createdAt: new Date() },
    ])

    return { previous }
  },
  onError: (err, variables, context) => {
    queryClient.setQueryData(["comments", entityType, entityId], context.previous)
    toast.error("Failed to add comment")
  },
  onSuccess: () => {
    toast.success("Comment added")
  },
})
```

### RBAC Implementation

[Source: [docs/architecture/coding-standards.md](docs/architecture/coding-standards.md#api--backend-standards)]

**Access Control Pattern:**

```typescript
// Verify project access before allowing comment mutations
const projectAccess = await ctx.db.query.projectAccess.findFirst({
  where: and(
    eq(projectAccess.projectId, input.projectId),
    eq(projectAccess.userId, ctx.user.id),
    isNotNull(projectAccess.acceptedAt),
    isNull(projectAccess.deletedAt)
  ),
})

const isOwner = project?.ownerId === ctx.user.id
const hasAccess = isOwner || projectAccess

if (!hasAccess) {
  throw new TRPCError({ code: "FORBIDDEN", message: "You do not have access to this project" })
}
```

**Comment Ownership Verification:**

```typescript
// User can only edit/delete their own comments
const comment = await ctx.db.query.comments.findFirst({
  where: eq(comments.id, input.commentId),
})

const isCommentOwner = comment.userId === ctx.user.id
const isProjectOwner = project.ownerId === ctx.user.id

if (!isCommentOwner && !isProjectOwner) {
  throw new TRPCError({ code: "FORBIDDEN", message: "You cannot delete this comment" })
}
```

### Markdown Rendering & XSS Protection

**react-markdown Configuration:**

```typescript
import ReactMarkdown from "react-markdown"
import remarkGfm from "remark-gfm"
import DOMPurify from "dompurify"

// Sanitize content before rendering
const sanitizedContent = DOMPurify.sanitize(comment.content)

<ReactMarkdown
  remarkPlugins={[remarkGfm]}
  allowedElements={["p", "strong", "em", "a", "br"]}
  disallowedElements={["img", "script", "iframe", "html"]}
  unwrapDisallowed={true}
  components={{
    a: ({ href, children }) => {
      // Prevent javascript: URLs
      const isSafe = href && (href.startsWith("http://") || href.startsWith("https://"))
      return isSafe ? (
        <a href={href} target="_blank" rel="noopener noreferrer">
          {children}
        </a>
      ) : (
        <span>{children}</span>
      )
    },
  }}
>
  {sanitizedContent}
</ReactMarkdown>
```

**Character Limit Enforcement:**

- Client-side: React Hook Form with Zod validation (max 2000 characters)
- Server-side: Zod validation in tRPC input schema (max 2000 characters)
- Display: Character counter in textarea (e.g., "1523 / 2000")

### @Mention Implementation

**Autocomplete Pattern:**

1. Detect "@" character in textarea
2. Extract partial username after "@" (e.g., "@joh" â†’ query for "joh")
3. Query project members via tRPC: `projects.getMembers({ projectId, search: "joh" })`
4. Display dropdown with matching users (Avatar + Name)
5. On selection, insert "@username" into textarea
6. Parse submitted content for @mentions: `/@(\w+)/g`
7. Query users by username to get user IDs
8. Send notifications to mentioned users

**Libraries:**

- Option 1: Custom implementation with textarea cursor position tracking
- Option 2: `react-mentions` library (more robust, handles edge cases)

**Notification Parsing:**

```typescript
// Extract @mentions from comment content
function extractMentions(content: string): string[] {
  const mentionRegex = /@(\w+)/g
  const matches = content.matchAll(mentionRegex)
  return Array.from(matches, (m) => m[1]) // Extract username
}

// In comments.create mutation:
const mentions = extractMentions(input.content)
const mentionedUsers = await ctx.db.query.users.findMany({
  where: inArray(users.username, mentions),
})

// Send notification to each mentioned user
for (const user of mentionedUsers) {
  await createNotification({
    userId: user.id,
    type: NotificationType.COMMENT_ADDED,
    entityType: input.entityType,
    entityId: input.entityId,
    projectId: input.projectId,
    message: `${ctx.user.name} mentioned you in a comment`,
  })
}
```

### Project Structure

[Source: [docs/architecture/unified-project-structure.md](docs/architecture/unified-project-structure.md)]

**File Locations:**

```
apps/web/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ server/
â”‚   â”‚   â”œâ”€â”€ db/schema/
â”‚   â”‚   â”‚   â””â”€â”€ comments.ts                    # New comments schema
â”‚   â”‚   â”œâ”€â”€ api/routers/
â”‚   â”‚   â”‚   â”œâ”€â”€ comments.ts                    # New comments router
â”‚   â”‚   â”‚   â””â”€â”€ __tests__/
â”‚   â”‚   â”‚       â””â”€â”€ comments.test.ts
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ notifications.ts               # Modify: Add notifyCommentAdded()
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â””â”€â”€ comments/
â”‚   â”‚       â”œâ”€â”€ CommentThread.tsx              # New comment thread container
â”‚   â”‚       â”œâ”€â”€ CommentItem.tsx                # New single comment display
â”‚   â”‚       â”œâ”€â”€ NewCommentForm.tsx             # New comment form
â”‚   â”‚       â””â”€â”€ __tests__/
â”‚   â”‚           â”œâ”€â”€ CommentThread.test.tsx
â”‚   â”‚           â”œâ”€â”€ CommentItem.test.tsx
â”‚   â”‚           â””â”€â”€ NewCommentForm.test.tsx
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â””â”€â”€ projects/[projectId]/
â”‚   â”‚       â”œâ”€â”€ costs/[costId]/page.tsx        # Modify: Add CommentThread
â”‚   â”‚       â”œâ”€â”€ documents/[documentId]/page.tsx # Modify: Add CommentThread
â”‚   â”‚       â””â”€â”€ events/[eventId]/page.tsx      # Modify: Add CommentThread
â”œâ”€â”€ drizzle/migrations/
â”‚   â””â”€â”€ 0006_add_comments.sql                  # New migration
```

### Real-Time Updates

[Source: Story 8.1 implementation]

**React Query Polling Pattern:**

```typescript
// Fetch comments with 30s refetch interval
const { data: comments, isLoading } = api.comments.list.useQuery(
  { entityType, entityId },
  {
    refetchInterval: 30000, // 30 seconds
    refetchOnWindowFocus: true,
    staleTime: 20000, // Consider data stale after 20s
  }
)
```

**Polling Rationale:**

- WebSocket overhead not justified for comment frequency
- 30s polling provides "near real-time" experience
- Consistent with Story 8.1 notification polling
- React Query handles background refetching automatically
- User can manually refresh if needed

### Testing Standards

[Source: [docs/architecture/testing-strategy.md](docs/architecture/testing-strategy.md)]

**Test Coverage Requirements:**

**Backend Unit Tests:**

- Comments router (list, create, update, delete, getCount)
- RBAC verification (project access, comment ownership)
- Character limit validation (2000 max)
- Soft delete functionality
- Notification generation on comment creation
- @mention parsing and notification

**Component Tests:**

- CommentThread (renders comments, loading/empty states, real-time updates)
- CommentItem (displays comment, reply/edit/delete buttons, markdown rendering, XSS protection)
- NewCommentForm (submits comment, validates length, clears form, character counter)

**Integration Tests:**

- Create comment â†’ notification sent to entity owner
- Reply to comment â†’ notification sent to parent commenter
- @mention â†’ notification sent to mentioned user
- Edit comment â†’ updatedAt timestamp updated, "Edited" indicator shows
- Delete comment â†’ soft delete, placeholder shows

**E2E Tests:**

- Full comment thread flow (add comment, reply, edit, delete)
- @mention autocomplete flow
- Comment count badge updates after adding comment

## Testing

### Test Location

[Source: [docs/architecture/testing-strategy.md](docs/architecture/testing-strategy.md)]

**Backend Tests:**

- Router tests: `apps/web/src/server/api/routers/__tests__/comments.test.ts`
- Service tests: `apps/web/src/server/services/__tests__/notifications.test.ts` (modify)

**Component Tests:**

- CommentThread: `apps/web/src/components/comments/__tests__/CommentThread.test.tsx`
- CommentItem: `apps/web/src/components/comments/__tests__/CommentItem.test.tsx`
- NewCommentForm: `apps/web/src/components/comments/__tests__/NewCommentForm.test.tsx`

**E2E Tests:**

- Comment flow: `apps/web/e2e/tests/comments.spec.ts`

### Test Standards

**Framework:** Vitest ^1.6.0 for unit/integration tests, Playwright ^1.40.0 for E2E

**Testing Pattern:**

```typescript
import { describe, it, expect, vi } from "vitest"
import { appRouter } from "../root"
import { createTestContext } from "@/test/test-db"

describe("comments.create", () => {
  it("creates comment and triggers notification", async () => {
    const ctx = await createTestContext()
    const caller = appRouter.createCaller(ctx)

    const comment = await caller.comments.create({
      entityType: "cost",
      entityId: "cost-123",
      projectId: "project-123",
      content: "This is a test comment",
    })

    expect(comment).toMatchObject({
      content: "This is a test comment",
      userId: ctx.user.id,
      entityType: "cost",
      entityId: "cost-123",
    })

    // Verify notification was created
    const notifications = await ctx.db.query.notifications.findMany({
      where: eq(notifications.entityId, comment.id),
    })

    expect(notifications.length).toBeGreaterThan(0)
  })

  it("rejects comment over 2000 characters", async () => {
    const ctx = await createTestContext()
    const caller = appRouter.createCaller(ctx)

    const longContent = "a".repeat(2001)

    await expect(
      caller.comments.create({
        entityType: "cost",
        entityId: "cost-123",
        projectId: "project-123",
        content: longContent,
      })
    ).rejects.toThrow()
  })
})
```

## Change Log

| Date       | Version | Description                                                                                              | Author |
| ---------- | ------- | -------------------------------------------------------------------------------------------------------- | ------ |
| 2025-11-04 | 1.0     | Initial story creation                                                                                   | Bob    |
| 2025-11-04 | 1.1     | Validation fixes: entity type consistency, backend nesting validation, deduplication, query invalidation | Sarah  |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent_
