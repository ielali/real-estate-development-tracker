# Story 8.3: Threaded Comments on Entities

## Status

Draft

## Story

**As a** project owner or partner,
**I want** to add comments and replies to costs, documents, and timeline events,
**so that** I can collaborate with team members, ask questions, and provide context directly on project entities without needing external communication.

## Acceptance Criteria

1. [ ] Comments table created with proper schema and indexes
2. [ ] Comment thread component displays below costs, documents, events
3. [ ] Comments sorted chronologically (oldest first)
4. [ ] New comment form visible at bottom of thread
5. [ ] Comment submission creates comment and clears form
6. [ ] Comment form has character counter (2000 max)
7. [ ] User avatar, name, and timestamp display on each comment
8. [ ] "Reply" button shows inline reply form with cancel option
9. [ ] Nested replies indented and visually connected to parent
10. [ ] One-level nesting enforced (no nested reply buttons on replies)
11. [ ] Edit button works for own comments (inline edit form)
12. [ ] Delete button works for own comments and project owner
13. [ ] Deleted comments show "[Comment deleted]" placeholder
14. [ ] "Edited" indicator shows if comment was modified
15. [ ] Notifications generated for new comments
16. [ ] Comment count badge shows on entity cards
17. [ ] @mention autocomplete searches project members
18. [ ] Mentioned users receive notifications
19. [ ] Markdown rendering works (bold, italic, links)
20. [ ] XSS protection implemented (sanitize HTML)
21. [ ] Comments respect RBAC (only project members can comment)
22. [ ] Real-time updates work (new comments appear within 30s)
23. [ ] Empty state shows "No comments yet" with prompt

## Tasks / Subtasks

- [ ] Create comments database schema (AC: 1)
  - [ ] Create Drizzle schema file: `apps/web/src/server/db/schema/comments.ts`
  - [ ] Define `comments` table with fields:
    - [ ] `id` (uuid, primary key)
    - [ ] `userId` (text, foreign key to users.id, CASCADE on delete)
    - [ ] `entityType` (text, enum: 'cost', 'document', 'event')
    - [ ] `entityId` (text, non-null, indexed for entity lookups)
    - [ ] `projectId` (text, foreign key to projects.id, CASCADE on delete)
    - [ ] `content` (text, max 2000 characters)
    - [ ] `parentCommentId` (text, nullable, foreign key to comments.id, SET NULL on delete)
    - [ ] `createdAt` (timestamp, default now())
    - [ ] `updatedAt` (timestamp, default now(), updated on edit)
    - [ ] `deletedAt` (timestamp, nullable, for soft delete)
  - [ ] Create indexes:
    - [ ] Composite index on (entityType, entityId) for fast entity comment lookups
    - [ ] Index on userId for user comment queries
    - [ ] Index on projectId for project-scoped queries
    - [ ] Index on parentCommentId for reply queries
  - [ ] Generate migration file: `bunx drizzle-kit generate`
  - [ ] Apply migration to production: `NETLIFY_DATABASE_URL="..." bunx drizzle-kit push`
  - [ ] Export schema from `apps/web/src/server/db/schema/index.ts`

- [ ] Create tRPC comments router (AC: 2, 4, 5, 11, 12, 21)
  - [ ] Create router file: `apps/web/src/server/api/routers/comments.ts`
  - [ ] Implement `list` query:
    - [ ] Input: `{ entityType: string, entityId: string }` (Zod validation)
    - [ ] Verify authentication (protected procedure)
    - [ ] Query comments for entity where deletedAt IS NULL
    - [ ] Include user name/avatar via join
    - [ ] Sort by createdAt ASC (oldest first)
    - [ ] Group replies under parent comments
    - [ ] Return: Comment[] with nested replies
  - [ ] Implement `create` mutation:
    - [ ] Input: `{ entityType, entityId, projectId, content, parentCommentId? }` (Zod validation)
    - [ ] Verify authentication and project access (RBAC check)
    - [ ] Validate content length â‰¤ 2000 characters
    - [ ] If parentCommentId provided:
      - [ ] Verify parent exists and is not deleted
      - [ ] Verify parent is not itself a reply (enforce one-level nesting only)
      - [ ] Throw TRPCError BAD_REQUEST if parent has parentCommentId: "Cannot reply to a reply - only one level nesting allowed"
    - [ ] Create comment in database
    - [ ] Trigger notification generation (entity owner, thread participants, @mentions)
    - [ ] Return: created Comment
  - [ ] Implement `update` mutation:
    - [ ] Input: `{ commentId: string, content: string }` (Zod validation)
    - [ ] Verify authentication
    - [ ] Verify user owns comment (userId === ctx.user.id)
    - [ ] Update comment content and updatedAt timestamp
    - [ ] Return: updated Comment
  - [ ] Implement `delete` mutation:
    - [ ] Input: `{ commentId: string }` (Zod validation)
    - [ ] Verify authentication
    - [ ] Verify user owns comment OR user is project owner
    - [ ] Soft delete: Set deletedAt = NOW()
    - [ ] Return: success boolean
  - [ ] Implement `getCount` query:
    - [ ] Input: `{ entityType: string, entityId: string }` (Zod validation)
    - [ ] Count comments where deletedAt IS NULL
    - [ ] Return: number
  - [ ] Add router to root router in `apps/web/src/server/api/root.ts`

- [ ] Create CommentThread UI component (AC: 2, 3, 4, 7, 8, 9, 10, 13, 23)
  - [ ] Create component file: `apps/web/src/components/comments/CommentThread.tsx`
  - [ ] Component props:
    - [ ] `entityType: 'cost' | 'document' | 'event'`
    - [ ] `entityId: string`
    - [ ] `projectId: string`
  - [ ] Use tRPC `comments.list` query to fetch comments
  - [ ] Implement loading state (skeleton components)
  - [ ] Implement empty state: "No comments yet. Be the first to comment!"
  - [ ] Map comments to CommentItem components
  - [ ] Sort comments by createdAt (oldest first) - server already does this
  - [ ] Render top-level comments first, then nested replies
  - [ ] Add NewCommentForm at bottom of thread
  - [ ] Implement real-time updates: React Query refetch interval 30s (AC #22)

- [ ] Create CommentItem component (AC: 7, 8, 9, 10, 11, 12, 13, 14)
  - [ ] Create component file: `apps/web/src/components/comments/CommentItem.tsx`
  - [ ] Component props:
    - [ ] `comment: Comment`
    - [ ] `currentUserId: string`
    - [ ] `projectOwnerId: string`
    - [ ] `isReply: boolean` (for styling indentation)
    - [ ] `onReplySubmit: (content: string, parentId: string) => void`
    - [ ] `onEdit: (commentId: string, content: string) => void`
    - [ ] `onDelete: (commentId: string) => void`
  - [ ] Display user avatar (Shadcn/ui Avatar component)
  - [ ] Display user name and timestamp (format with date-fns)
  - [ ] Display comment content with markdown rendering (react-markdown)
  - [ ] Show "Edited" indicator if updatedAt > createdAt + 1 minute
  - [ ] Show deleted placeholder if deletedAt is set: "[Comment deleted]"
  - [ ] Show "Reply" button (only if not a reply - one-level nesting)
  - [ ] Show "Edit" and "Delete" buttons if user owns comment
  - [ ] Project owner can see "Delete" button on any comment
  - [ ] Implement inline reply form (toggle visibility on "Reply" click)
  - [ ] Implement inline edit form (toggle visibility on "Edit" click)
  - [ ] On successful edit/delete, invalidate `comments.list` query for real-time updates
  - [ ] Apply indentation styling for replies (ml-8 border-l-2)

- [ ] Create NewCommentForm component (AC: 4, 5, 6)
  - [ ] Create component file: `apps/web/src/components/comments/NewCommentForm.tsx`
  - [ ] Component props:
    - [ ] `entityType: string`
    - [ ] `entityId: string`
    - [ ] `projectId: string`
    - [ ] `parentCommentId?: string` (for replies)
    - [ ] `onSuccess: () => void`
    - [ ] `onCancel?: () => void` (for inline reply forms)
    - [ ] `placeholder?: string`
  - [ ] Use React Hook Form with Zod validation
  - [ ] Textarea input (Shadcn/ui Textarea component)
  - [ ] Character counter: "X / 2000 characters"
  - [ ] Disable submit if content is empty or > 2000 characters
  - [ ] Submit button: "Comment" or "Reply" based on context
  - [ ] Cancel button (only for inline reply/edit forms)
  - [ ] On submit: call `comments.create` mutation
  - [ ] Clear form after successful submission
  - [ ] Invalidate queries on success for real-time updates:
    - [ ] Invalidate `comments.list` query for current entity
    - [ ] Invalidate `comments.getCount` query for current entity (updates badge)
  - [ ] Show error toast on failure (Shadcn/ui toast)
  - [ ] Implement @mention autocomplete (AC #17):
    - [ ] Detect "@" character in textarea
    - [ ] Query project members via tRPC
    - [ ] Show autocomplete dropdown with user names
    - [ ] Insert "@username" on selection
    - [ ] Use `react-mentions` or custom implementation

- [ ] Add markdown rendering support (AC: 19)
  - [ ] Install `react-markdown` library: `bun add react-markdown`
  - [ ] Install `remark-gfm` for GitHub-flavored markdown: `bun add remark-gfm`
  - [ ] Configure markdown renderer in CommentItem:
    - [ ] Allowed elements: strong, em, a, p, br
    - [ ] Disallow: img, script, iframe, html tags
    - [ ] Sanitize links to prevent javascript: URLs
  - [ ] Install `dompurify` for XSS protection: `bun add dompurify`
  - [ ] Sanitize HTML output in CommentItem (AC #20)

- [ ] Add comment notifications (AC: 15, 18)
  - [ ] Update `apps/web/src/server/services/notifications.ts`:
    - [ ] Add `notifyCommentAdded` function
    - [ ] Collect notification recipients:
      - [ ] Entity owner (cost/document/event creator)
      - [ ] All previous commenters in thread (distinct user IDs)
      - [ ] Parse content for @mentions (regex: /@(\w+)/g)
      - [ ] Query users by username from @mentions
      - [ ] Mentioned users
    - [ ] Deduplicate all recipients (entity owner + thread participants + @mentions) by user ID
    - [ ] Exclude comment author from notifications (no self-notification)
    - [ ] Send one notification per unique user ID
    - [ ] Use NotificationType.COMMENT_ADDED
    - [ ] Message template: "{userName} commented on {entityType} in {projectName}"
  - [ ] Call `notifyCommentAdded` from `comments.create` mutation
  - [ ] Implement email notifications (Story 8.2 integration):
    - [ ] Create email template for comment notifications using Resend
    - [ ] Template structure:
      - [ ] Subject: "{commenterName} commented on {entityType} in {projectName}"
      - [ ] Body includes: Commenter name and avatar
      - [ ] Body includes: Comment content (first 200 characters with "..." if truncated)
      - [ ] Body includes: Entity name/description
      - [ ] Body includes: Project name
      - [ ] Body includes: Direct link to entity with comment thread (deep link)
      - [ ] Body includes: Unsubscribe link (managed via Story 8.2 preferences)
    - [ ] Respect user email preferences (emailOnComment toggle)
    - [ ] Fire-and-forget pattern (don't block comment creation on email failure)

- [ ] Add comment count badges (AC: 16)
  - [ ] Update cost card component: `apps/web/src/components/costs/CostCard.tsx`
    - [ ] Add tRPC `comments.getCount` query
    - [ ] Display comment count badge (Shadcn/ui Badge)
    - [ ] Format: "ðŸ’¬ {count}" if count > 0
  - [ ] Update document card component: `apps/web/src/components/documents/DocumentCard.tsx`
    - [ ] Same implementation as cost card
  - [ ] Update timeline event card: `apps/web/src/components/events/EventCard.tsx`
    - [ ] Same implementation as cost card

- [ ] Integrate CommentThread into entity pages
  - [ ] Cost detail page: `apps/web/src/app/projects/[projectId]/costs/[costId]/page.tsx`
    - [ ] Add CommentThread component below cost details
    - [ ] Pass entityType="cost", entityId=costId, projectId
  - [ ] Document detail page: `apps/web/src/app/projects/[projectId]/documents/[documentId]/page.tsx`
    - [ ] Add CommentThread component below document preview
    - [ ] Pass entityType="document", entityId=documentId, projectId
  - [ ] Timeline event detail page: `apps/web/src/app/projects/[projectId]/events/[eventId]/page.tsx`
    - [ ] Add CommentThread component below event details
    - [ ] Pass entityType="event", entityId=eventId, projectId

- [ ] Write comprehensive tests (AC: 1-23)
  - [ ] Backend router tests: `apps/web/src/server/api/routers/__tests__/comments.test.ts`
    - [ ] Test `list` query (returns comments for entity, excludes deleted)
    - [ ] Test `create` mutation (creates comment, triggers notifications)
    - [ ] Test `create` with parent (creates reply, enforces one-level nesting)
    - [ ] Test `update` mutation (updates own comment, rejects others')
    - [ ] Test `delete` mutation (soft deletes own comment, project owner can delete any)
    - [ ] Test `getCount` query (counts non-deleted comments)
    - [ ] Test RBAC (user must be project member to comment)
    - [ ] Test character limit validation (2000 max)
  - [ ] Component tests:
    - [ ] CommentThread.test.tsx (renders comments, loading/empty states, real-time updates)
    - [ ] CommentItem.test.tsx (displays comment, reply/edit/delete buttons, markdown rendering)
    - [ ] NewCommentForm.test.tsx (submits comment, validates length, clears form)
  - [ ] Integration tests:
    - [ ] Create comment â†’ notification sent to entity owner
    - [ ] Reply to comment â†’ notification sent to parent commenter
    - [ ] @mention â†’ notification sent to mentioned user
    - [ ] Edit comment â†’ updatedAt timestamp updated
    - [ ] Delete comment â†’ soft delete, shows placeholder
  - [ ] E2E tests:
    - [ ] Full comment thread flow (add comment, reply, edit, delete)
    - [ ] @mention autocomplete flow
    - [ ] Comment count badge updates

## Dev Notes

### Previous Story Insights

**From Story 8.1 (In-App Notifications - Complete):**

- Notification generation system working well via `notifications.ts` service
- `notifyProjectMembers()` function batches notifications to all project members
- `createNotification()` for single-user notifications
- NotificationType enum includes COMMENT_ADDED (ready to use)
- Real-time updates via React Query polling (30s interval) proven effective

**From Story 8.2 (Email Notifications - Complete):**

- Email template system in place using Resend
- User preferences system with `emailOnComment` toggle
- Fire-and-forget email pattern prevents transaction failures
- Email templates include project name, entity description, direct links
- Rate limiting (10 emails/hour) already implemented

**Key Takeaways:**

- Extend existing notification system to trigger on comment creation
- Follow established tRPC procedure patterns (protectedProcedure, Zod validation)
- Use Shadcn/ui components for consistency (Textarea, Avatar, Button, Badge)
- Implement RBAC at query level (verify project access before mutations)
- Use soft delete pattern for comments (deletedAt timestamp)
- Real-time updates via React Query refetchInterval (30s)

### Tech Stack

[Source: [docs/architecture/tech-stack.md](docs/architecture/tech-stack.md)]

**Core Technologies:**

- Frontend: Next.js ^14.2.0, TypeScript ^5.3.0, React Query ^5.0.0
- UI: Shadcn/ui ^0.8.0, Tailwind CSS ^3.4.0
- Backend: tRPC ^10.45.0, Drizzle ORM ^0.44.6
- Database: Neon PostgreSQL (serverless)
- Validation: Zod ^3.22.0 for runtime validation
- Testing: Vitest ^1.6.0, Testing Library ^14.0.0, Playwright ^1.40.0

**Additional Libraries Needed:**

- `react-markdown` ^9.0.0 - Markdown rendering for comment content
- `remark-gfm` ^4.0.0 - GitHub-flavored markdown support (bold, italic, links)
- `dompurify` ^3.0.0 - HTML sanitization for XSS protection
- `react-mentions` ^4.4.0 (optional) - @mention autocomplete functionality
- `date-fns` ^3.0.0 - Already installed, use for timestamp formatting

### Data Models

[Source: [docs/architecture/data-models.md](docs/architecture/data-models.md)]

**New Model: Comment**

```typescript
interface Comment extends BaseEntity {
  id: string // UUID
  userId: string // Foreign key to users.id (CASCADE)
  entityType: "cost" | "document" | "event"
  entityId: string // ID of the related entity
  projectId: string // Foreign key to projects.id (CASCADE)
  content: string // Max 2000 characters
  parentCommentId: string | null // Foreign key to comments.id (SET NULL)
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null // Soft delete
}
```

**Database Schema (Drizzle):**

```typescript
import { pgTable, text, timestamp, uuid, index } from "drizzle-orm/pg-core"
import { users } from "./users"
import { projects } from "./projects"

export const CommentEntityType = {
  COST: "cost",
  DOCUMENT: "document",
  EVENT: "event",
} as const

export type CommentEntityType = (typeof CommentEntityType)[keyof typeof CommentEntityType]

export const comments = pgTable(
  "comments",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    entityType: text("entity_type").notNull(), // One of CommentEntityType
    entityId: text("entity_id").notNull(),
    projectId: text("project_id")
      .notNull()
      .references(() => projects.id, { onDelete: "cascade" }),
    content: text("content").notNull(), // Max 2000 characters (enforce in Zod)
    parentCommentId: uuid("parent_comment_id").references(() => comments.id, {
      onDelete: "set null",
    }),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
    deletedAt: timestamp("deleted_at"),
  },
  (table) => ({
    // Composite index for entity comment lookups
    entityIdx: index("comments_entity_idx").on(table.entityType, table.entityId),
    // Index for user comment queries
    userIdIdx: index("comments_user_id_idx").on(table.userId),
    // Index for project-scoped queries
    projectIdIdx: index("comments_project_id_idx").on(table.projectId),
    // Index for reply queries
    parentIdIdx: index("comments_parent_id_idx").on(table.parentCommentId),
  })
)
```

**Relations:**

- Belongs to User (commenter)
- Belongs to Project
- Belongs to Comment (parent, optional)
- Has many Comments (replies)

### Existing Notification System

[Source: [apps/web/src/server/services/notifications.ts](apps/web/src/server/services/notifications.ts)]

**Notification Generation Functions:**

```typescript
// Create single notification
createNotification({
  userId: string,
  type: NotificationType,
  entityType: NotificationEntityType,
  entityId: string,
  projectId: string,
  message: string
}): Promise<void>

// Notify all project members (owner + partners)
notifyProjectMembers({
  projectId: string,
  excludeUserId?: string, // Avoid self-notification
  type: NotificationType,
  entityType: NotificationEntityType,
  entityId: string,
  messageData: Record<string, unknown>
}): Promise<void>
```

**NotificationType.COMMENT_ADDED:**

- Already defined in schema: `apps/web/src/server/db/schema/notifications.ts`
- Message template: `"{commenterName} commented on {entityType} in {projectName}"`
- Entity types: 'cost', 'document', 'event'

**Notification Integration Points:**

1. **New Comment:** Notify entity owner + previous thread participants (deduplicated)
2. **@Mentions:** Parse content for @username, notify mentioned users
3. **Email Integration:** Respect `emailOnComment` preference from Story 8.2

### Component Patterns

[Source: [docs/architecture/coding-standards.md](docs/architecture/coding-standards.md)]

**Form Pattern:**

```typescript
// Standard pattern: React Hook Form + Zod + Shadcn/ui
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"

const commentSchema = z.object({
  content: z.string().min(1, "Comment cannot be empty").max(2000, "Comment too long"),
})

const form = useForm<z.infer<typeof commentSchema>>({
  resolver: zodResolver(commentSchema),
})
```

**Loading States:**

```typescript
// Initial load: Show skeleton components
if (isLoading) {
  return <CommentListSkeleton count={3} />
}

// Empty state: Friendly message with clear CTA
if (comments.length === 0) {
  return (
    <EmptyState
      icon="ðŸ’¬"
      title="No comments yet"
      description="Be the first to comment on this item!"
    />
  )
}
```

**Optimistic Updates:**

```typescript
// Create comment: Add immediately, rollback on error
const createMutation = api.comments.create.useMutation({
  onMutate: async (newComment) => {
    await queryClient.cancelQueries(["comments", entityType, entityId])
    const previous = queryClient.getQueryData(["comments", entityType, entityId])

    // Optimistically add comment
    queryClient.setQueryData(["comments", entityType, entityId], (old) => [
      ...old,
      { ...newComment, id: "temp", createdAt: new Date() },
    ])

    return { previous }
  },
  onError: (err, variables, context) => {
    queryClient.setQueryData(["comments", entityType, entityId], context.previous)
    toast.error("Failed to add comment")
  },
  onSuccess: () => {
    toast.success("Comment added")
  },
})
```

### RBAC Implementation

[Source: [docs/architecture/coding-standards.md](docs/architecture/coding-standards.md#api--backend-standards)]

**Access Control Pattern:**

```typescript
// Verify project access before allowing comment mutations
const projectAccess = await ctx.db.query.projectAccess.findFirst({
  where: and(
    eq(projectAccess.projectId, input.projectId),
    eq(projectAccess.userId, ctx.user.id),
    isNotNull(projectAccess.acceptedAt),
    isNull(projectAccess.deletedAt)
  ),
})

const isOwner = project?.ownerId === ctx.user.id
const hasAccess = isOwner || projectAccess

if (!hasAccess) {
  throw new TRPCError({ code: "FORBIDDEN", message: "You do not have access to this project" })
}
```

**Comment Ownership Verification:**

```typescript
// User can only edit/delete their own comments
const comment = await ctx.db.query.comments.findFirst({
  where: eq(comments.id, input.commentId),
})

const isCommentOwner = comment.userId === ctx.user.id
const isProjectOwner = project.ownerId === ctx.user.id

if (!isCommentOwner && !isProjectOwner) {
  throw new TRPCError({ code: "FORBIDDEN", message: "You cannot delete this comment" })
}
```

### Markdown Rendering & XSS Protection

**react-markdown Configuration:**

```typescript
import ReactMarkdown from "react-markdown"
import remarkGfm from "remark-gfm"
import DOMPurify from "dompurify"

// Sanitize content before rendering
const sanitizedContent = DOMPurify.sanitize(comment.content)

<ReactMarkdown
  remarkPlugins={[remarkGfm]}
  allowedElements={["p", "strong", "em", "a", "br"]}
  disallowedElements={["img", "script", "iframe", "html"]}
  unwrapDisallowed={true}
  components={{
    a: ({ href, children }) => {
      // Prevent javascript: URLs
      const isSafe = href && (href.startsWith("http://") || href.startsWith("https://"))
      return isSafe ? (
        <a href={href} target="_blank" rel="noopener noreferrer">
          {children}
        </a>
      ) : (
        <span>{children}</span>
      )
    },
  }}
>
  {sanitizedContent}
</ReactMarkdown>
```

**Character Limit Enforcement:**

- Client-side: React Hook Form with Zod validation (max 2000 characters)
- Server-side: Zod validation in tRPC input schema (max 2000 characters)
- Display: Character counter in textarea (e.g., "1523 / 2000")

### @Mention Implementation

**Autocomplete Pattern:**

1. Detect "@" character in textarea
2. Extract partial username after "@" (e.g., "@joh" â†’ query for "joh")
3. Query project members via tRPC: `projects.getMembers({ projectId, search: "joh" })`
4. Display dropdown with matching users (Avatar + Name)
5. On selection, insert "@username" into textarea
6. Parse submitted content for @mentions: `/@(\w+)/g`
7. Query users by username to get user IDs
8. Send notifications to mentioned users

**Libraries:**

- Option 1: Custom implementation with textarea cursor position tracking
- Option 2: `react-mentions` library (more robust, handles edge cases)

**Notification Parsing:**

```typescript
// Extract @mentions from comment content
function extractMentions(content: string): string[] {
  const mentionRegex = /@(\w+)/g
  const matches = content.matchAll(mentionRegex)
  return Array.from(matches, (m) => m[1]) // Extract username
}

// In comments.create mutation:
const mentions = extractMentions(input.content)
const mentionedUsers = await ctx.db.query.users.findMany({
  where: inArray(users.username, mentions),
})

// Send notification to each mentioned user
for (const user of mentionedUsers) {
  await createNotification({
    userId: user.id,
    type: NotificationType.COMMENT_ADDED,
    entityType: input.entityType,
    entityId: input.entityId,
    projectId: input.projectId,
    message: `${ctx.user.name} mentioned you in a comment`,
  })
}
```

### Project Structure

[Source: [docs/architecture/unified-project-structure.md](docs/architecture/unified-project-structure.md)]

**File Locations:**

```
apps/web/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ server/
â”‚   â”‚   â”œâ”€â”€ db/schema/
â”‚   â”‚   â”‚   â””â”€â”€ comments.ts                    # New comments schema
â”‚   â”‚   â”œâ”€â”€ api/routers/
â”‚   â”‚   â”‚   â”œâ”€â”€ comments.ts                    # New comments router
â”‚   â”‚   â”‚   â””â”€â”€ __tests__/
â”‚   â”‚   â”‚       â””â”€â”€ comments.test.ts
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ notifications.ts               # Modify: Add notifyCommentAdded()
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â””â”€â”€ comments/
â”‚   â”‚       â”œâ”€â”€ CommentThread.tsx              # New comment thread container
â”‚   â”‚       â”œâ”€â”€ CommentItem.tsx                # New single comment display
â”‚   â”‚       â”œâ”€â”€ NewCommentForm.tsx             # New comment form
â”‚   â”‚       â””â”€â”€ __tests__/
â”‚   â”‚           â”œâ”€â”€ CommentThread.test.tsx
â”‚   â”‚           â”œâ”€â”€ CommentItem.test.tsx
â”‚   â”‚           â””â”€â”€ NewCommentForm.test.tsx
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â””â”€â”€ projects/[projectId]/
â”‚   â”‚       â”œâ”€â”€ costs/[costId]/page.tsx        # Modify: Add CommentThread
â”‚   â”‚       â”œâ”€â”€ documents/[documentId]/page.tsx # Modify: Add CommentThread
â”‚   â”‚       â””â”€â”€ events/[eventId]/page.tsx      # Modify: Add CommentThread
â”œâ”€â”€ drizzle/migrations/
â”‚   â””â”€â”€ 0006_add_comments.sql                  # New migration
```

### Real-Time Updates

[Source: Story 8.1 implementation]

**React Query Polling Pattern:**

```typescript
// Fetch comments with 30s refetch interval
const { data: comments, isLoading } = api.comments.list.useQuery(
  { entityType, entityId },
  {
    refetchInterval: 30000, // 30 seconds
    refetchOnWindowFocus: true,
    staleTime: 20000, // Consider data stale after 20s
  }
)
```

**Polling Rationale:**

- WebSocket overhead not justified for comment frequency
- 30s polling provides "near real-time" experience
- Consistent with Story 8.1 notification polling
- React Query handles background refetching automatically
- User can manually refresh if needed

### Testing Standards

[Source: [docs/architecture/testing-strategy.md](docs/architecture/testing-strategy.md)]

**Test Coverage Requirements:**

**Backend Unit Tests:**

- Comments router (list, create, update, delete, getCount)
- RBAC verification (project access, comment ownership)
- Character limit validation (2000 max)
- Soft delete functionality
- Notification generation on comment creation
- @mention parsing and notification

**Component Tests:**

- CommentThread (renders comments, loading/empty states, real-time updates)
- CommentItem (displays comment, reply/edit/delete buttons, markdown rendering, XSS protection)
- NewCommentForm (submits comment, validates length, clears form, character counter)

**Integration Tests:**

- Create comment â†’ notification sent to entity owner
- Reply to comment â†’ notification sent to parent commenter
- @mention â†’ notification sent to mentioned user
- Edit comment â†’ updatedAt timestamp updated, "Edited" indicator shows
- Delete comment â†’ soft delete, placeholder shows

**E2E Tests:**

- Full comment thread flow (add comment, reply, edit, delete)
- @mention autocomplete flow
- Comment count badge updates after adding comment

## Testing

### Test Location

[Source: [docs/architecture/testing-strategy.md](docs/architecture/testing-strategy.md)]

**Backend Tests:**

- Router tests: `apps/web/src/server/api/routers/__tests__/comments.test.ts`
- Service tests: `apps/web/src/server/services/__tests__/notifications.test.ts` (modify)

**Component Tests:**

- CommentThread: `apps/web/src/components/comments/__tests__/CommentThread.test.tsx`
- CommentItem: `apps/web/src/components/comments/__tests__/CommentItem.test.tsx`
- NewCommentForm: `apps/web/src/components/comments/__tests__/NewCommentForm.test.tsx`

**E2E Tests:**

- Comment flow: `apps/web/e2e/tests/comments.spec.ts`

### Test Standards

**Framework:** Vitest ^1.6.0 for unit/integration tests, Playwright ^1.40.0 for E2E

**Testing Pattern:**

```typescript
import { describe, it, expect, vi } from "vitest"
import { appRouter } from "../root"
import { createTestContext } from "@/test/test-db"

describe("comments.create", () => {
  it("creates comment and triggers notification", async () => {
    const ctx = await createTestContext()
    const caller = appRouter.createCaller(ctx)

    const comment = await caller.comments.create({
      entityType: "cost",
      entityId: "cost-123",
      projectId: "project-123",
      content: "This is a test comment",
    })

    expect(comment).toMatchObject({
      content: "This is a test comment",
      userId: ctx.user.id,
      entityType: "cost",
      entityId: "cost-123",
    })

    // Verify notification was created
    const notifications = await ctx.db.query.notifications.findMany({
      where: eq(notifications.entityId, comment.id),
    })

    expect(notifications.length).toBeGreaterThan(0)
  })

  it("rejects comment over 2000 characters", async () => {
    const ctx = await createTestContext()
    const caller = appRouter.createCaller(ctx)

    const longContent = "a".repeat(2001)

    await expect(
      caller.comments.create({
        entityType: "cost",
        entityId: "cost-123",
        projectId: "project-123",
        content: longContent,
      })
    ).rejects.toThrow()
  })
})
```

## Change Log

| Date       | Version | Description                                                                                              | Author |
| ---------- | ------- | -------------------------------------------------------------------------------------------------------- | ------ |
| 2025-11-04 | 1.0     | Initial story creation                                                                                   | Bob    |
| 2025-11-04 | 1.1     | Validation fixes: entity type consistency, backend nesting validation, deduplication, query invalidation | Sarah  |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent_
